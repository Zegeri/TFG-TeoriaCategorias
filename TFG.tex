%!TEX TS-program = pdflatex
%!TEX encoding = utf8
\documentclass[12pt, twoside]{book}
\usepackage[T1]{fontenc}
\usepackage{bussproofs}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english, spanish, es-noshorthands]{babel}

\usepackage{hyperref}
\usepackage{url}
\usepackage{epigraph}

\usepackage{tikz}
\usetikzlibrary{babel}
\usetikzlibrary{cd}

%% FONTS: libertine+biolinum+stix
\usepackage{mathpazo}

% =====================
% = Datos importantes =
% =====================
% hay que rellenar estos datos y luego
% ir a \begin{document}

\title{Teoría de Categorías y Programación Funcional}
\author{Diego Pedraza López}
\date{\today}
\newcommand{\tutores}[1]{\newcommand{\guardatutores}{#1}}
\tutores{Prof. Tutor José A. Alonso Jiménez}

% ======================
% = Páginas de títulos =
% ======================
\makeatletter
\edef\maintitle{\@title}
\renewcommand\maketitle{%
  \begin{titlepage}
      \vspace*{1.5cm}
      \parskip=0pt
      \Huge\bfseries
      \begin{center}
          %\leavevmode\includegraphics[totalheight=6cm]{sello.pdf}\\[2cm]
          \@title
      \end{center}
      \vspace{1cm}
      \begin{center}
          \@author
      \end{center}
  \end{titlepage}

  \begin{titlepage}
  \parindent=0pt
  \begin{flushleft}
  \vspace*{1.5mm}
  \setlength\baselineskip{0pt}
  \setlength\parskip{0mm}
  \begin{center}
      %\leavevmode\includegraphics[totalheight=4.5cm]{sello.pdf}
  \end{center}
  \end{flushleft}
  \vspace{1cm}
  \bgroup
  \Large \bfseries
  \begin{center}
  \@title
  \end{center}
  \egroup
  \vspace*{.5cm}
  \begin{center}
  \@author
  \end{center}
  \vspace*{1.8cm}
  \begin{flushright}
  \begin{minipage}{8.45cm}
      Memoria presentada como parte de los requisitos para la obtención del título de
      Grado en Matemáticas por la Universidad de Sevilla.

      \vspace*{7.5mm}

      Tutorizada por
      % \vspace*{5mm}
  \end{minipage}\par
  \begin{tabularx}{8.45cm}[b]{@{}l}
      \guardatutores
  \end{tabularx}
   \end{flushright}
      \vspace*{\fill}
   \end{titlepage}
   %%% Esto es necesario...
   \pagestyle{tfg}
   \renewcommand{\chaptermark}[1]{\markright{\thechapter.\space ##1}}
   \renewcommand{\sectionmark}[1]{}
   \renewcommand{\subsectionmark}[1]{}
  }
\makeatother

\usepackage{minted}
\newcommand{\newterm}[1]{\index{#1}\emph{#1}}
\newcommand{\code}[1]{\Verb+{#1}+}

% ======================================
% = Color de la Universidad de Sevilla =
% ======================================
\definecolor{USred}{cmyk}{0,1.00,0.65,0.34}

% =========
% = Otros =
% =========
\usepackage[]{tabularx}
\usepackage[]{enumitem}
\setlist{noitemsep}

% ==========================
% = Matemáticas y teoremas =
% ==========================
\usepackage[]{amsmath}
\usepackage[]{amsthm}
\usepackage[]{mathtools}
\usepackage[]{bm}
\usepackage[]{thmtools}
\usepackage[]{amsfonts}
\newcommand{\marcador}{\vrule height 10pt depth 2pt width 2pt \hskip .5em\relax}
\newcommand{\cabeceraespecial}{%
    \color{USred}%
    \normalfont\bfseries}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\cabeceraespecial\marcador,
    notefont=\cabeceraespecial,
    notebraces={(}{)},
    bodyfont=\normalfont\itshape,
    postheadspace=1em,
    numberwithin=chapter,
    headindent=0pt,
    headpunct={.}
    ]{importante}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\normalfont\itshape\color{USred},
    notefont=\normalfont,
    notebraces={(}{)},
    bodyfont=\normalfont,
    postheadspace=1em,
    numberwithin=chapter,
    headindent=0pt,
    headpunct={.}
    ]{normal}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\normalfont\itshape\color{USred},
    notefont=\normalfont,
    notebraces={(}{)},
    bodyfont=\normalfont,
    postheadspace=1em,
    headindent=0pt,
    headpunct={.},
    numbered=no,
    qed=\color{USred}\marcador
    ]{demostracion}

% Los nombres de los enunciados. Añade los que necesites.
\declaretheorem[name=Observaci\'on, style=normal]{remark}
\declaretheorem[name=Corolario, style=normal]{corollary}
\declaretheorem[name=Proposici\'on, style=normal]{proposition}
\declaretheorem[name=Lema, style=normal]{lemma}
\declaretheorem[name=Ejemplo, style=normal]{example}

\declaretheorem[name=Teorema, style=importante]{theorem}
\declaretheorem[name=Definici\'on, style=importante]{definition}

\let\proof=\undefined
\declaretheorem[name=Demostraci\'on, style=demostracion]{proof}

\usepackage{scalerel}
\newcommand{\cat}{{\mathcal{C}}}
\newcommand{\Set}{{Set}}
\newcommand{\Grp}{{Grp}}
\newcommand{\Ab}{{Ab}}
\newcommand{\Vect}{{Vect}}
\newcommand{\Ring}{{Ring}}
\newcommand{\Cat}{{Cat}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\Top}{{Top}}
\newcommand{\Hask}{{Hask}}
\newcommand{\sii}{{\ \Leftrightarrow\ }}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\Const}{Const}

\hyphenation{func-tor}
\hyphenation{func-to-res}

% ============================
% = Composición de la página =
% ============================
\usepackage[
    a4paper,
    textwidth=80ex,
]{geometry}

\linespread{1.069}
\parskip=10pt plus 1pt minus .5pt
\frenchspacing
% \raggedright

\setlength{\headheight}{20pt}
% ==============================
% = Composición de los títulos =
% ==============================

\usepackage[explicit]{titlesec}

\titleformat{\chapter}[hang]
    {\Huge\sffamily\bfseries}
    {\thechapter\hspace{20pt}\textcolor{USred}{\vrule width 2pt}\hspace{20pt}}{0pt}
    {#1}
\titleformat{\section}
  {\normalfont\Large\sffamily\bfseries}{\thesection\space\space}
  {1ex}
  {#1}
\titleformat{\subsection}
  {\normalfont\large\sffamily}{\thesubsection\space\space}
  {1ex}
  {#1}

% =======================
% = Cabeceras de página =
% =======================
\usepackage[]{fancyhdr}
\usepackage[]{emptypage}
 \fancypagestyle{tfg}{%
     \fancyhf{}%
     \renewcommand{\headrulewidth}{0pt}
     \renewcommand{\footrulewidth}{0pt}
     \fancyhead[LE]{{\normalsize\color{USred}\bfseries\thepage}\quad
                     \small\textsc{\MakeLowercase{\maintitle}}}
     \fancyhead[RO]{\small\textsc{\MakeLowercase{\rightmark}}%
                     \quad{\normalsize\bfseries\color{USred}\thepage}}%
                     }
\usepackage{makeidx}
\makeindex
\usepackage{csquotes} % comillas españolas

% =============================
% = El documento empieza aquí =
% =============================
\begin{document}

\maketitle

\frontmatter
\tableofcontents

\mainmatter


\chapter*{English Abstract}
\addcontentsline{toc}{chapter}{English Abstract}
\markright{English Abstract}

\begin{otherlanguage}{english}
    We will explore the realm of category theory and its connections with other fields of mathematics using functional programming.
\end{otherlanguage}

\chapter{Introducción}
La teoría de categorías nos ofrece al mismo tiempo un lenguaje común por el que se pueden entender matemáticos y programadores, y una poderosa abstracción a la composición de funciones.
Para explorar la teoría de categorías haremos uso de la programación funcional.
Más concrétamente, usaremos Haskell, que es uno de los lenguajes puramente funcionales más populares.

\section{Programación funcional}
La programación funcional es un estilo de programación que tiene sus origenes en IPL (1956) y Lisp (1958).
Aunque durante mucho tiempo ha tenido un interés más académico que práctico, ha estado teniendo más atención en los últimos años.
Lenguajes de gran popularidad como C++ o Java han introducido características de la programación funcional en los últimos años.
\footnote{Since the introduction of the STL (Standard Template Library) -- about 1994 -- there has been a steady and cautious increase in the use of functional programming techniques in C++. -- Bjarne Stroustrup, creador de C++}
Algunos lenguajes, como Haskell o Standard ML, están diseñados con programación funcional en mente.
Encuentran su inspiración en las matemáticas y sus características principales son:

\begin{itemize}
  \item \emph{Funciones puras}. Las subrutinas no dejan efectos secundarios en memoria, por lo que sólo dependen en sus argumentos y no en el estado de la máquina.
  Por lo tanto, las funciones puras son más cercanas a las funciones con las que trabajan los matemáticos.
  \item \emph{Sistema de tipos fuertes}. El lenguaje categoriza los datos por tipos y restringe la aplicaciones de funciones a ciertos tipos, de manera que la expresión \code{"texto" + 1} da un error de compilación.
  A menudo hay un sistema de \emph{inferencia de tipo}, de manera que no es necesario tener que escribir los tipos constantemente.
  \item \emph{Funciones polimórficas}. En consecuencia del punto anterior y para permitir escribir funciones genéricas, se permite escribir funciones que actúen tipos arbitrarios. Por ejemplo, en Haskell, la declaración de tipo
  \begin{minted}{haskell}
  f :: forall a. a -> a
  \end{minted}
  % =
  % \end{minted}
  describe \code{f} como una función que puede ser aplicado a todo tipo y devuelve el mismo tipo de salida.
  Una función equivalente en C++ sería de la forma:
  \begin{minted}{c++}
  template<class A>
  A f(A arg);
  \end{minted}
  Sin embargo, la programación funcional permite imponer restricciones a los tipos polimórficos que son validabes en compilación a través de mecanismos como las \emph{clases de tipos} en Haskell.
  Son similares a las \emph{interfaces} de los lenguajes de programación orientada a objetos como Java.
  En algunos lenguajes funcionales, se permite además imponer restricciones de tipos al tipo polimórfico devuelto de una función, por ejemplo:
  \begin{minted}{haskell}
  read :: forall a. (Read a) => String -> a
  \end{minted}
  % =
  % \end{minted}
  Esta función interpreta una cadena de texto como un tipo cualquiera \code{a} que sea de la clase de tipo \code{Read}.
  \item \emph{Tipos de datos algebraicos}. Pueden representar suma de tipos, además de producto de tipos.
  Esto permite la existencia de tipos definiciones recursivas como listas o árboles sin hacer uso de punteros.
  Además no son mutables (por el hecho de que las funciones no pueden tener efectos secundario), por lo que no hay una diferencia esencial entre los datos del constructor y los datos que almacena el tipo de datos.

  Por esta razón, la programación funcional suele resultar algo difícil para programadores acostumbrados a programar con efectos secundarios.
  Por otro lado, permite procesar los argumentos de una función por patrones.

  \item \emph{Evaluación perezosa}. Aunque no es característica de todos los lenguajes funcionales --por ejemplo, SML no lo incorpora--, muchos lenguajes funcionales como Haskell y Mirando lo adoptan.
  La evaluación perezosa permite que los argumentos de una función sean evaluados sólamente cuando sea necesario.
  Esto permite trabajar estructuras de datos infinitas, que en todo momento sólo están parcialmente definidas.
\end{itemize}

\section{Haskell}
Vamos a introducir lo mínimo de Haskell para poder entender el código que aquí se da.
No tendremos una imagen completa del lenguaje, pero sí lo suficiente para poder seguir el código.
Si ya está familiarizado con Haskell, puede saltarse esta sección.

Haskell nos permite \emph{declarar} una variable y su tipo:
\begin{minted}{haskell}
x :: Int
\end{minted}
y \emph{definir} el valor de dicha variable:
\begin{minted}{haskell}
x = 8
\end{minted}
Evidentemente, implementa aritmética básica:
\begin{minted}{haskell}
y = (x + 4) * 5
-- Esto es un comentario
-- y = 60
\end{minted}
Las funciones se definen de forma similar:
\begin{minted}{haskell}
duplica :: Int -> Int
duplica x = 2 * x
\end{minted}
Obsérvese que no se ponen paréntesis alrededor de los parámetros.
Tampoco se usan paréntesis cuando aplicamos la función, es decir, \code{duplica 3} es una expresión correcta.

Las funciones de varios parámetros se definen como funciones de orden superior:
\begin{minted}{haskell}
multiplica :: Int -> Int -> Int
multiplica x y = x * y
\end{minted}
Podemos entender que \code{multiplica} toma dos enteros y los multiplica, pero también se puede interpretar que \code{multiplica} se aplica a \code{x} y devuelve una función con tipo \code{Int -> Int}, que podemos a su vez aplicar al otro argumento.
Esta idea nos lleva al concepto de funciones parcialmente aplicadas:
\begin{minted}{haskell}
duplica' :: Int -> Int
duplica' x = multiplica 2 x
\end{minted}

Podemos definir funciones polimórficas, como explicamos en la sección anterior:
\begin{minted}{haskell}
max :: Ord a => a -> a -> a 
max x y =
  if x < y
  then x 
  else y
\end{minted}
Aquí vemos además la estructura condicional habitual \texttt{if-then-else}.

Trabajaremos a menudo a nivel de funciones, por lo que resultará útil echar un ojo al operador composición:
\begin{minted}{haskell}
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
\end{minted}
Toda función declarada entre paréntesis, como \code{(.)}, se corresponde con un operador infijo.
Por otro lado, la expresión $\backslash$\code{x -> f (g x)} representa una función de un sólo parámetro \code{x} y que devuelve \code{f (g x)}.
Más específicamente, representa la expresión lambda $\lambda x. f(g x)$.

Hablemos también un poco sobre los tipos de datos algebraicos.
Un tipo de dato se define con una expresión de la forma
\begin{minted}{haskell}
data Dato t1 ... tn = 
  Constructor1 a11 ... a1m | ... | ConstructorM aM1 ... aMq
\end{minted}
donde \code{t1 ... tn} son argumentos del tipo \code{Dato}, que tiene distintos constructores \code{Constructor1},\dots, \code{ConstructorM} cada uno con sus correspondientes parámetros.

Para entender mejor esto, veamos un ejemplo:
\begin{minted}{haskell}
data Maybe a = Nothing | Just a
\end{minted}
El tipo de dato \code{Maybe a} tiene dos constructores: \code{Nothing} (sin parámetro) y \code{Just a}, de parámetro \code{a}.
Recordemos que, en programación funcional, los constructores tienen toda la información sobre el tipo de dato, por lo que podemos identificar todo objeto del tipo \code{Maybe a} con uno de sus constructores.

Esto nos lleva a la interpretación que un objeto de tipo \code{Maybe a} es \code{Nothing} o bien \code{Just a}.
Pero cuidado, no confunda el constructor con el tipo.
Tanto \code{Nothing} como \code{Just 24} son del tipo \code{Maybe Int}.
Para definir una función que tome \code{Maybe a} por defecto, suele venir bien definirla por casos:
\begin{minted}{haskell}
maybe_a_numero :: Maybe Int -> Int
maybe_a_numero Nothing  = 0
maybe_a_numero (Just x) = x
\end{minted}

Otro tipo que nos resultará de utilidad es el tipo de listas \code{[a]}.
Esto tipo se salta algunas reglas de como está descrito para ser más sencillo de escribir.
Podemos definirlo en pseudo-haskell como:
\begin{minted}{haskell}
data [a] = a : [a] | []
\end{minted}
Es decir, una lista de elementos del tipo \code{a} es o bien una lista vacía \code{[]}, o bien un elemento de tipo \code{a} y otra lista del mismo tipo.

Podemos definir \emph{clases} sobre los tipos que implementen alguna función particular, por ejemplo:
\begin{minted}{haskell}
class Eq a where
  (==) :: a -> a -> Bool
\end{minted}
% =
% \end{minted}
define la clase de los tipos sobre los que está definido el operador igualdad \code{(==)}.
Si queremos que un tipo esté en la clase \code{Eq}, tendremos que escribir su instancia.
Como ejemplo, supongamos que queremos escribir la instancia de \code{Maybe a} en la clase \code{Eq}.
Si los dos elementos del tipo \code{Maybe a} son de la forma \code{Nothing}, diremos que son iguales.
Si no, comparamos el argumento de \code{Just a}.
Pero para ello, el tipo \code{a} debe ser también de la clase \code{Eq}.
Por ello, una implementación sería:
\begin{minted}{haskell}
instance Eq a => Eq (Maybe a) where
  Nothing == Nothing = True
  Nothing == Just x  = False
  Just x  == Nothing = False
  Just x  == Just x  = x == x
\end{minted}

\section{Referencias}
\begin{itemize}
  \item Thompson, S. (1991). \emph{Type theory \& functional programming}, Capítulo 2.
  \item Pierce, B.C. (1991). \emph{A taste of category theory for computer scientist}, Capítulo 1.
  \item Lipovaca, M. (2011). \emph{Learn You a Haskell for Great Good!: A Beginner's Guide}.
\end{itemize}
\chapter{Fundamentos}
\section{Categorías}

% Abramsky - Logic and categories as tools for building theories
La idea empieza por el concepto de categoría, que resulta sorprendentemente ubicua en la matemática.
En principio, una categoría es sólo una colección de objetos y flechas entre dichos objetos donde se define una composición de flechas.
Veremos que algunas de la categorías más interesantes son las relacionadas con las estructuras matemáticas, como $\Top$, la categoría de espacios topológicos y funciones continuas, o $\Grp$, la categoría de grupos y homomorfismos.
En estos casos, la teoría de categorías sirve como un marco de las teorías matemáticas.
Las aplicaciones entre categorías --functores-- ilustran las conexiones entre distintas teorías matemáticas.
Aunque los axiomas que pediremos a las categorías no son muchos, resulta que podemos crear una gran cantidad de resultados interesantes y muy genéricos.

\begin{definition}
Una \newterm{categoría} $\cat$ es:
\begin{itemize}
\item Una colección de \index{objeto}\emph{objetos} $O(\cat)$.
\item A cada par de objetos $A$, $B$ en $O(\cat)$, una colección de \index{morfismo}\emph{morfismos} $C(A,B)$ de $A$ a $B$.
Un morfismo $f$ en $C(A,B)$ se denotará $f \colon A \to B$.
\item A cada par de morfismos $f \colon A \to B$, $g \colon B \to C$, un morfismo de $g \circ f \colon A \to C$ llamado \newterm{morfismo composición} de $f$ y $g$.
\end{itemize}
de manera que:
\begin{itemize}
\item Para cada objeto $A \in O(\cat)$, existe un morfismo $\id_A \in C(A,A)$ que llamamos \newterm{morfismo identidad}.
\item Para todo morfismo $f \colon A \to B$:
\[ \id_B \circ f = f \circ \id_A = f \]
\item Asociatividad de la composición: Para toda tripleta de morfismos $f \colon A \to B$, $g \colon B \to C$, $h \colon C \to D$:
\begin{equation}\label{cat:3} (h \circ g) \circ f = h \circ (g \circ f) \end{equation}
\end{itemize}
\end{definition}

La notación para referirse a objetos y morfismos de una categoría varía mucho dependiendo del autor.
Por ejemplo, Awodey usa $\cat_0$ y $\cat_1$ para referirse a los objetos y los morfismos de una categoría $\cat$ respectivamente~\cite{awodey}.
Esta notación funciona bien para la introducción de categorías de orden superior.

Otra notación habitual es usar $Hom(A,B)$ para referirse a la colección de morfismos entre $A$ y $B$, lo que hemos llamado $C(A,B)$.

A menudo usaremos diagramas para expresar visualmente ciertas propiedades.
En Teoría de Categoría, existe una definición precisa de diagrama, pero por ahora, no tenemos las herramientas suficientes para explicarlo.
Basta imaginar que es un grafo formado por una cantidad finita de objetos y morfismos de una categoría.

El concepto de conmutatividad de un diagrama es el habitual de otros campos.
Como ejemplo, la propiedad \eqref{cat:3} se puede expresar diciendo que el diagrama
\[
\begin{tikzcd}
A \arrow[rr,"f"]\arrow[rrdd,pos=0.1,"g \circ f" sloped] \arrow[dd,"h\circ g \circ f" left] & & B \arrow[lldd,pos=0.4,"h\circ g" sloped, crossing over] \arrow[dd,"g"]\\
&\\
C & & D \arrow[ll,"h"]
\end{tikzcd}
\]
conmuta.

Dado un morfismo $f \colon A \to B$, llamaremos dominio de $f$ a $\dom f = A$.
De igual manera, el codominio de $f$ será $\cod f = B$.

Además, llamaremos a la colección de morfismos de una categoría $M(\cat)$.

No hay ni mucho menos falta de ejemplos de categorías, ni siquiera si nos limitamos a un campo específicio de la matemática.
Algunos ejemplos ilustrativos son los siguientes:

\begin{example}
La categoría $\Set$ formada por los conjuntos como objetos y funciones entre conjuntos como morfismos.
La composición de morfismos se corresponde, como es de esperar, con la composición de funciones.
\end{example}

\begin{example}
La categoría $\Grp$ formada por los grupos como objetos y homomorfismos entre grupos como morfismos.
\end{example}

\begin{example}
La categoría $\Top$ formada por los espacios topológicos como objetos y funciones continuas como morfismos.
\end{example}

\begin{example}
Todo \newterm{conjunto parcialmente ordenado} (o \index{poset|see {conjunto parcialmente ordenado}}\emph{poset}) $(X,\leq)$ puede verse como una categoría, donde los objetos son los elementos de $X$ y hay un único morfismo $f \colon a \to b$ si y sólo si $a \leq b$.
Este es nuestro primer ejemplo donde los morfismos no son equivalentes a función.
La composición de dos morfismos aquí es equivalente a la propiedad transitiva de la relación de orden $\leq$.
Es más, el morfismo identidad es equivalente a la propiedad reflexiva.
\end{example}

También nos interesarán en algunos casos categorías que posean una estructura finita dada, como:
\begin{example}
La categoría $\mathbb{1}$ formada por un sólo objeto y su morfismo identidad:
\[ \begin{tikzcd}
A \arrow[loop above,"\id_A"]
\end{tikzcd}\]
\end{example}

\begin{example}
La categoría $\mathbb{2}$:
\[ \begin{tikzcd}
A \arrow[loop above,"\id_A"] \arrow[r,"f"] & B \arrow[loop above,"\id_B"]
\end{tikzcd}\]
\end{example}

Las categorías finitas serán de gran uso cuando hablemos más adelante de los diagramas.
Por otro lado, las categorías con las que trabajaremos a menudo serán enormes, donde a veces la teoría de conjuntos habitual se nos quedará pequeña.
Por ejemplo, en la teoría de conjuntos habitual, el conjunto de todos los conjuntos es una noción inconsistente como consecuencia del Teorema de Cantor.
Por esta razón, hablaremos a menudo de \textquote{colección} o \textquote{familia} y evitaremos la palabra \textquote{conjunto} en general.

En ocasiones, sí nos será útil que la colección de objetos o morfismos forme un conjunto.
Para ello, introducimos las siguientes definiciones:

\begin{definition}
Una categoría $\cat$ es \index{categoría!pequeña}\emph{pequeña} si $O(\cat)$ y $M(\cat)$ forman conjuntos.
\end{definition}

Por ejemplo, toda categoría finita es pequeña, pero $\Set$ no es pequeña.

\begin{definition}
Una categoría $\cat$ es \index{categoría!localmente pequeña}\emph{localmente pequeña} si para todo par de objetos $A$ y $B$ en $\cat$, $C(A,B)$ forma un conjunto.
\end{definition}

Todos los ejemplos que hemos dado son localmente pequeños.
Para poder dar ejemplos de categorías que no son localmente pequeñas, necesitaremos más conceptos.
Casi siempre trabajaremos con categorías localmente pequeñas.

También podemos construir categorías a partir de otras categorías.
El ejemplo más importante es el de la categoría opuesta:
\begin{definition}
Dada una categoría $\cat$, la \index{categoría!opuesta}\emph{categoría opuesta} o \index{categoría!dual}\emph{dual} $\cat^{op}$ es la categoría con los mismos objetos que $\cat$ y donde un morfismo $f \colon B \to A$ en $\cat^{op}$ es un morfismo $f \colon A \to B$ en $\cat$.
\end{definition}

Evidentemente se tiene que $\left(\cat^{op}\right)^{op} = \cat$.
A menudo nos encontraremos con conceptos que están relacionados por el dual de una categoría.
Por ejemplo, el objeto terminal de una categoría (que veremos más adelante) no es más que el objeto inicial de su categoría opuesta.

\begin{definition}
Sea $A$, $B$ objetos de una categoría $\cat$.
Un morfismo $f \colon B \to C$ de una categoría es un monomorfismo (o mónico) si para todo morfismo $g \colon A \to B$ y $h \colon A \to B$ tales que $f \circ g = f \circ h$, entonces $g = h$.
\end{definition}

\begin{proposition}
En \Set, un morfismo es mónico si y sólo si es inyectivo.
\end{proposition}

\begin{proof}
Sea $f \colon B \to C$ un monomorfismo. Sean $b, b' \in B$ tales que $f(b) = f(b')$. Sea $A = \{b\}$ y definimos $g \colon A \to B$ como $g(b)=b'$.
Entonces $f(\id_A(b)) = f(g(b))$
como $b$ es el único elemento de $A$, tenemos que:
\[ f \circ \id_A = f \circ g \]
luego, como $f$ es monomorfismo:
\[ \id_A = g \]
Entonces $b'=g(b)=\id_A(b)=b$.

Consideramos ahora $f \colon B \to C$ un morfismo inyectivo.
Sean los morfismos $g, h \colon A \to B$ tales que $f \circ g = f \circ h$.
Sea $a \in A$ cualquiera. Como $f(g(a)) = f(h(a))$ y $f$ es inyectiva, entonces $g(a) = h(a)$.
Es decir, se tiene que $g = h$. 
\end{proof}

\begin{definition}
Un morfismo $f \colon A \to B$ es epimorfismo (o épico) si para cualquier par de morfismos $g \colon B \to C$ y $h \colon B \to C$, se tiene que $g \circ f = h \circ f$ implica que $g = h$.
\end{definition}

\begin{proposition}
En \Set, un morfismo es épico si y sólo si es sobreyectivo.
\end{proposition}

\begin{proof}
Sea $f \colon A \to B$ un epimorfismo. Supongamos que $f$ no fuera sobreyectivo. Entonces existe $b \in B$ que no es imagen de ningún elemento de $A$. Sean $g, h \colon B \to \{1,2\}$ tal que $g(x)=h(x)=1$ para todo $x \in B \setminus \{b\}$, $g(b) = 1$ y $h(b) = 2$. Entonces tenemos que $g \circ f = h \circ f$. Como $f$ es epimorfismo, esto implica que $g = h$, pero esto entra en una contradicción.

Sea $f \colon A \to B$ un morfismo sobreyectivo. Sean $g, h \colon B \to C$ tales que $g \circ f = h \circ f$. Para todo $b \in B$, existe $a \in A$ tal que $f(a)=b$, luego: $g(b) = g(f(a)) = h(f(a)) = h(b)$, luego $g = h$.
\end{proof}

\begin{definition}
Un morfismo $f \colon A \to B$ es \newterm{isomorfismo} si existe $g \colon B \to A$ tal que $g \circ f = \id_A$ y $f \circ g = \id_B$.

Dos objetos $A$ y $B$ se dirán \emph{isomorfos} si existe un isomorfismo entre ellos.
\end{definition}

Claramente, en $\Set$, un morfismo mónico y épico es isomórfico.
Sin embargo, todos los morfismos de un poset son épicos y mónicos, pero sólo los morfismos identidad son isomorfismos.

\section{Functores}
Parece que muchos conceptos como $\Set$ o $\Top$ forman categorías.
De aquí surge la siguiente cuestión: ¿Podríamos hacer una categoría de categorías?
Es decir, una categoría donde los objetos mismos sean categorías.
Para ello, debemos definir morfismos entre categorías que respetan su estructura interna.
Aunque la misma razón por la que no hay conjunto de conjuntos, no hay una categoría de categorías, esta cuestión motiva la definición de functor:

\begin{definition}\label{def:functor}
Un \newterm{functor} $F$ entre un par de categorías $\cat$ y $\mathcal{D}$ es un par de funciones:
\begin{itemize}
\item $F_O : O(\cat) \to O(\mathcal{D})$.
\item $F_M : M(\cat) \to M(\mathcal{D})$.
\end{itemize}
tal que:
\begin{itemize}
\item Respeta el dominio y codominio de los morfismos: A cada morfismo $f : A \to B$:
\[ F_M(f) : F_O(A) \to F_O(B) \]
\item Respeta el morfismo identidad:
\[ F_M(\id_A) = \id_{F_O(A)} \]
\item Respeta la composición de morfismo: Para todo morfismos $f : A \to B$, $g : B \to C$.
\[ F_M(g \circ f) = F_M(g) \circ F_M(f) \]
\end{itemize}
\end{definition}

Escribiremos $F \colon \cat \to \mathcal{D}$ y a menudo usaremos $F$ para referirnos a $F_M$ ó $F_O$ según el contexto.

Viendo los functores como funciones entre categorías, es natural que queramos definir composición entre functores.
\begin{definition}
Dado dos functores $F \colon \cat \to \mathcal{D}$ y $G \colon \mathcal{D} \to \mathcal{E}$, definimos $G \circ F$ como el functor con:
\begin{itemize}
  \item $(G \circ F)_O = G_O \circ F_O$.
  \item $(G \circ F)_M = G_M \circ F_M$.
\end{itemize}
\end{definition}
\subsection{Functores en Haskell}
Recordemos que en el contexto de la programación con tipos, Haskell sólo trabaja con tipos de la categoría \code{Hask}.
Los functores con los que podemos trabajar son de endofunctores de \code{Hask}, es decir, functores que van de \code{Hask} a \code{Hask} -- de tipos a tipos.

Haskell implementa los functores a través de sus \code{typeclasses}.
\begin{minted}{haskell}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{minted}

La \code{f} actúa como $F$ y como $F_O$ en \ref{def:functor}.
Si hay dudas de qué es lo que hace \code{fmap} aquí, resulta útil añadir unos paréntesis en el lugar adecuado:

\begin{minted}{haskell}
fmap :: (a -> b) -> (f a -> f b)
\end{minted}

\code{fmap} toma un función cualquiera \code{a -> b} y la transforma en una función del tipo \code{f a -> f b}.
Esto es precisamente lo que antes llamábamos $F_M$.
Con esto en mente, adaptemos las leyes de los functores en Haskell:
\begin{minted}{haskell}
fmap id = id
fmap (g . f) = fmap g . fmap f
\end{minted}
Recordemos que en Haskell, la composición de funciones $g \circ f$ se expresa usando \code{g . f}.
Antes de pasar a unos ejemplos, hay que tener en cuenta que Haskell no dispone de ningún mecanismo que comprueba que estas igualdades se cumplen.
Queda como responsabilidad del programador que la clase \code{Functor} no se aplique sobre tipos que no cumplen las leyes de functores. 

\begin{example}
Nuestro primer ejemplo es \code{Maybe}.
\begin{minted}{haskell}
data Maybe a = Nothing | Just a 
\end{minted}

Podemos leer esta definición como \code{Maybe a} contiene o bien un valor constante o bien un valor del tipo \code{a}.
Hay que tener cuidado con la diferencia entre \code{Maybe} y \code{Just}.
\code{Maybe} es lo que llamamos un constructor de tipo.
Veremos que este constructor de tipo, que asocia a cada tipo \code{a} el tipo \code{Maybe a}, es un functor.
Por otro lado, \code{Just} es una función polimórfica --y por lo tanto una familia de morfismos en \code{Hask}-- de \code{a} a \code{Maybe a}.

Para ver que \code{Maybe} es un functor, tenemos que describir como actúa sobre morfismos, ahí es donde entra en juego la función \code{fmap}.

\begin{minted}{haskell}
instance Functor Maybe where
  fmap f Nothing = Nothing
  fmap f (Just x) = Just (f x) 
\end{minted}
\end{example}

\subsection{Functores especiales}
Consideramos ahora el concepto de functor contravariante a través de un cambio en la definición de functor:
\begin{definition}\label{def:cofunctor}
Un \index{functor!contravariante}\emph{functor contravariante} $F$ entre un par de categorias $\cat$ y $\mathcal{D}$ es un par de funciones:
\begin{itemize}
\item $F_O : O(\cat) \to O(\mathcal{D})$.
\item $F_M : M(\cat) \to M(\mathcal{D})$.
\end{itemize}
tal que:
\begin{itemize}
\item \textbf{Intercambia} el dominio y codominio de los morfismos: A cada morfismo $f : A \to B$:
\[ F_M(f) : F_O(B) \to F_O(A) \]
\item Respeta el morfismo identidad:
\[ F_M(\id_A) = \id_{F_O(A)} \]
\item \textbf{Intercambia} la composición de morfismo: Para todo morfismos $f : A \to B$, $g : B \to C$.
\[ F_M(g \circ f) = F_M(f) \circ F_M(g) \]
\end{itemize}
\end{definition}

Los functores con los que hemos trabajado hasta ahora serán llamados \index{functor!covariante}\emph{functores covariantes}, pero a menudo prescindiremos del adjetivo.
Una razón para esto es que no hay diferencia esencial entre functor contravariante y functor covariante cuando observamos que los \textquote{intercambios} en la definición son equivalentes a que el functor parta de $\cat^{op}$.
Por esta razón, hablaremos de functor contravariante cuando tratemos con un functor covariante de la forma:
\[ F \colon \cat^{op} \to D \]

Otros functores reciben nombres especiales por su dominio o su codominio:
\begin{definition}
Un functor $F \colon \cat \to \cat$ se denomina \newterm{endofunctor}.
\end{definition}
%Categories and Haskell 1
\begin{example}
Un ejemplo sencillo es el \newterm{endofunctor potencia} $\mathcal{P} \colon \Set \to \Set$ que envía un conjunto $A$ a su conjunto potencia $\mathcal{P}(A)$ y envía a las funciones entre conjuntos $f \colon A \to B$ a la función $\mathcal{P} f \colon \mathcal{P}(A) \to \mathcal{P}(B)$ definida como:
\[ \mathcal{P} f (S) = \{f(s) \colon s \in S\}, \quad S \subseteq A \]
\end{example}

\begin{definition}
Un functor $F \colon \cat^{op} \times \cat \to \mathcal{D}$ se denomina \newterm{bifunctor}.
\end{definition}
Aquí $\cat^{op} \times \cat$ es la categoría producto de $\cat^{op}$ y $\cat$, definida más adelante en la sección 1.5.

\begin{definition}
Un functor $F \colon \cat^{op} \to \Set$ se denomina \newterm{prehaz}.
\end{definition}

\section{Construcciones universales}
Podemos caracterizar ciertos objetos en una categoría por alguna propiedad especial que cumplan. En lugar de pedir que sólo haya un objeto que cumpla dicha propiedad, nos limitamos a pedir que todos los objetos que cumplan la propiedad sean isomorfos. Estas propiedades son llamadas \emph{propiedades universales}.

\begin{definition}
Decimos que un objeto $A \in \cat$ es \newterm{inicial} si para cada objeto $B \in \cat$, hay exactamente un morfismo $f \colon A \to B$.

Análogamente, decimos que un objeto $B \in \cat$ es \newterm{terminal} si para cada objeto $A \in \cat$, hay exactamente un morfismo $f \colon A \to B$.
\end{definition}

Cuando hablemos de un objeto inicial, usaremos a menudo la notación $0$.
Análogamente, usaremos $1$ para referirnos a un objeto terminal.

\begin{example}
Veamos algunos ejemplos en categorías usuales:
\begin{itemize}
  \item En $\Set$, el conjunto vacío es un objeto inicial y cualquier conjunto unitario es terminal.
  \item En $\Grp$, el grupo trivial es inicial y terminal.
  \item En $\Ring$, el anillo unitario es terminal y el anillo $(\Z,+,\cdot)$ es inicial.
  \item En un poset, visto como categoría, el objeto inicial es el elemento mínimo global y el objeto terminal es el elemento máximo global, si existen.
\end{itemize}
\end{example}

De estos ejemplos vemos que:
\begin{itemize}
  \item Los objetos iniciales y terminales no son necesariamente únicos.
  \item Un objeto puede ser inicial y terminal.
  \item Una categoría puede no poseer objetos iniciales o terminales.
\end{itemize}

Aunque no haya unicidad de objetos iniciales o terminales, sí hay una relación entre todos los objetos iniciales o terminales.
\begin{proposition}
Sea $\cat$ una categoría. Sean $A$ y $B$ objetos iniciales (o terminales) de $\cat$.
Entonces existe un único isomorfismo $A \to B$.
\end{proposition}
\begin{proof}
Como $A$ es inicial, existe un único morfismo $f \colon A \to B$.
Como $B$ es inicial, existe un único morfismo $g \colon B \to A$.
Entonces $g \circ f \colon A \to A$.
Al ser $A$ inicial, sólo hay un morfismo $A \to A$, que debe ser el morfismo identidad, luego $g \circ f = \id_A$.
Análogamente, $f \circ g = \id_B$.

Luego $f$ es isomorfismo.
\end{proof}

\section{Diagramas y conos}
En estas páginas hemos trabajado a menudo con categorías con infinitos objetos e innumerables morfismos.
Sin embargo, resulta de interés estudiar una estructura particular de objetos y morfismos que podamos encontrar dentro de esa categoría.
Para ello, formalizaremos un concepto que hemos manejado antes, los diagramas.
\begin{definition}
Sean $\cat$ y $\mathcal{I}$ dos categorías. Un \newterm{diagrama} de $\cat$ con \emph{forma} $\mathcal{I}$ es un functor $D \colon \mathcal{I} \to \cat$.
\end{definition}
Es decir, técnicamente diagrama será sólo otra palabra para functor.
En la práctica, usaremos diagrama cuando querramos distinguir una estructura particular dentro de una categoría.
También se llamará a $\mathcal{I}$ \index{categoría!índice}\emph{categoría índice} del diagrama.

\begin{example}\label{ejemplo-span}
Sea $\mathcal{I}$ la siguiente categoría índice:
\[ \begin{tikzcd}
A & B \arrow[l] \arrow[r] & C
\end{tikzcd} \]
Entonces el diagrama $D \colon \mathcal{I} \to \cat$ es llamado \newterm{span}.
\end{example}

\begin{definition}
Sea $\cat$ una categoría y $D \colon \mathcal{I} \to \cat$ un diagrama de forma $\mathcal{I}$.
Un \newterm{cono} en el diagrama $D$ es un objeto $V \in \cat$ (que llamamos \newterm{vértice}) y una familia de morfismos $f_A \colon C \to D A$ para todo $A \in \mathcal{I}$, tal que para todo morfismo $g \colon A \to B$ de $\mathcal{I}$, el siguiente diagrama conmuta:
\[ \begin{tikzcd}
 & D A \arrow[dd,"D g"]\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"]\\
 & D B
\end{tikzcd} \]
\end{definition}

Una buena técnica para estudiar una nueva construcción es preguntarse: ¿Podemos formar una categoría con ella?

Lo que nos queda por hacer para crear una categoría de conos de un diagrama fijo $D$ es definir un morfismo entre conos.
Resulta intuitivo definirlo a partir de un morfismo entre los vértices.
Si $C$ y $C'$ son dos conos con vértices $V$ y $V'$ respectivamente, definimos el morfismo $C \to C'$ como un morfismo $u \colon V \to V'$ tal que el siguiente diagrama conmuta para todo $A \in \mathcal{I}$:
\[ \begin{tikzcd}
V \arrow[dr,"f_A"] \arrow[dd,"u"] &\\
 & D A\\
V' \arrow[ur,"f'_A"]
\end{tikzcd} \]

\begin{proposition}
Dado una categoría $\cat$ y un diagram $D \colon \mathcal{I} \to \cat$, los conos de $D$ forma una categoría llamada $\text{Cono}(D)$ con los morfismos descritos anteriormente.
\end{proposition}
La demostración es directa gracias a que $\cat$ es una categoría.

En esta categoría de conos, resulta de especial interés el objeto terminal.

\begin{definition}
Dado una categoría $\cat$ y un diagrama $D \colon \mathcal{I} \to \cat$, el \newterm{límite del diagrama} $D$ es el objeto terminal de $\text{Cono}(D)$.
\end{definition}

Usaremos la notación $\underset{\longleftarrow}\lim D$ para referirnos al límite de un diagrama si existe.

Podemos considerar el dual de estos conceptos.

\begin{definition}
Un \newterm{cocono} de $\cat$ es un cono de $\cat^{op}$.
En otras palabras, un cocono en un diagrama $D \colon \mathcal{I} \to \cat$ es un objeto $V \in \cat$ y una familia de morfismos $f_A \colon D A \to V$ para todo $A \in \mathcal{I}$, tal que para todo morfismo $g \colon B \to A$ de $\mathcal{I}$, el siguiente diagrama conmuta:
\[ \begin{tikzcd}
 & D A \arrow[dl,"f_A"]\\
V\\
 & D B \arrow[ul,"f_B"] \arrow[uu,"D g"]
\end{tikzcd} \]
\end{definition}

\begin{definition}
Un \newterm{colímite} es el objeto terminal de la categoría de coconos de un diagrama. Equivalentemente es el objeto inicial de la categoría de conos.
\end{definition}

\begin{definition}
Una categoría $\cat$ es \index{categoría!completa}\index{categoría!cocompleta}\emph{(co)completa} si existen todos los (co)límites de diagramas $D \colon \mathcal{I} \to \cat$ con $\mathcal{I}$ categoría pequeña.

Una categoría es \index{categoría!bicompleta}\emph{bicompleta} si es completa y cocompleta.
\end{definition}

\section{Productos y coproductos}

Resulta importante familiarizarse con la idea de límite antes de continuar, porque nos resultará muy útil para definir nuevos conceptos.

\begin{definition}
Sea $\mathcal{I}$ la categoría de dos objetos $I_1$ y $I_2$ y sin morfismos aparte de los morfismos identidad. El \newterm{producto} de dos objetos $A$ y $B$ en $\cat$ es el límite del diagrama $D \colon \mathcal{I} \to \cat$ con $D(I_1) = A$ y $D(I_2) = B$.

Escribiremos $A \times B$ para denotar el producto de $A$ y $B$.
\end{definition}

Desenvolvamos las definiciones para entender que significa realmente el producto de dos objetos $A$ y $B$.
Primero obsérvese que el diagrama $D$ actúa para \textquote{seleccionar} los objetos $A$ y $B$ y sus morfismos identidad.
Puede que haya algún morfismo entre $A$ y $B$, pero no son relevantes para el diagrama y, en consecuencia, ni para el límite.

Un cono sobre $D$ es de la forma:
\begin{equation}\label{producto-cono} \begin{tikzcd}
 & A\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"]\\
 & B
\end{tikzcd} \end{equation}

El producto $A \times B$, límite de $D$, puede ser visto como el cono terminal en la categorías de conos sobre $D$.
Es decir, para todo cono como en \ref{producto-cono}, debe existir un único morfismo de dicho cono al $A \times B$.
Desenvolvamos las definiciones aún más.
Digamos que el producto está formado por los objetos $A \times B$ (abusando un poco de notación aquí), $p_A \colon A \times B \to A$ y $p_B \colon A \times B \to B$.
Para todo $V$, $f_A \colon V \to A$ y $f_B \colon V \to B$, debe existir un $h \colon V \to A \times B$ tal que el siguiente diagrama conmute:

\[\begin{tikzcd}
 & A\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"] \arrow[r,dashed,"h"] & A \times B \arrow[u,"p_A"] \arrow[d,"p_B"]\\
 & B
\end{tikzcd}\]

o algebraicamente:
\[ f_A = p_A \circ h \]
\[ f_B = p_B \circ h \]
Es decir, podemos dar un par de morfismos $V \to A$ y $V \to B$ es equivalente a dar un morfismo $V \to A \times B$.
Luego, podemos volver a los objetos $A$ y $B$ usando unos morfismos fijos $p_A$ y $p_B$ (que llamamos \index{morfismo!proyección}\emph{proyecciones}).

\begin{definition}
Sea $\mathcal{I}$ la categoría de dos objetos $I_1$ y $I_2$ y sin morfismos aparte de los morfismos identidad. El \newterm{coproducto} de dos objetos $A$ y $B$ en $\cat$ es el colímite del diagrama $D \colon \mathcal{I} \to \cat$ con $D(I_1) = A$ y $D(I_2) = B$.

Escribiremos $A + B$ para denotar el coproducto de $A$ y $B$.
\end{definition}

Desarrollando como antes la definiciones tenemos que para todo $V$, $f_A \colon A \to V$, $f_B \colon B \to V$, se tiene que existe $h \colon A + B \to V$ tal que:

\[\begin{tikzcd}
 & A \arrow[dl,"f_A"] \arrow[d,"i_A"]\\
V & A + B \arrow[l,dashed,"h"]\\
 & B \arrow[ul,"f_B"] \arrow[u,"i_B"]
\end{tikzcd}\]
donde $i_A$ e $i_B$ son llamadas \newterm{inyecciones naturales}.

\begin{example}
No es de extrañar que en $\Set$, el producto de dos objetos es el producto cartesiano de dos conjuntos.
Por otro lado, el coproducto de dos conjuntos se corresponde con la unión disjunta.
\end{example}

\begin{example}\label{ejemplo-producto-pos}
Consideramos la categoría $Pos$ de conjuntos parcialmente ordenados (posets) donde los morfismos son funciones monótonas.
El producto de dos posets $P$ y $Q$ es un poset $P \times Q$ de pares $(p,q)$ con $p \in P$ y $q \in Q$ ordenado parcialmente por:
\[ (p,q) \leq (p',q') \sii p \leq p' \text{ y }q \leq q' \]
Las proyecciones $p_1 \colon P \times Q \to P$ y $p_2 \colon P \times Q \to Q$ son evidentemente monótonas, luego son morfismos de $Pos$.
\end{example}

\begin{example}
En $\Hask$, el producto de dos tipos \code{a} y \code{b} es el par \code{(a,b)} y las proyecciones son las funciones \code{fst :: (a,b) -> a} y \code{snd :: (a,b) -> b}.
También tenemos que \code{(a,b)} es isomorfo a:
\begin{minted}{haskell}
newtype Pair a b = Pair a b
\end{minted}
A su vez, el coproducto de dos tipos \code{a} y \code{b} es el tipo \code{Either a b}, cuya definición es:
\begin{minted}{haskell}
data Either a b = Left a | Right b
\end{minted}
Es más, tenemos que todos los tipos de datos compuestos son isomorfos a productos y coproductos.
\end{example}

%Riehl 1
\begin{example}
En \index{categoría!{de categorías pequeñas}}\emph{categoría de categorías pequeñas} $\Cat$, el producto de dos categorías $\cat$ y $\mathcal{D}$ es una categoría $\cat \times \mathcal{D}$ cuyos objetos son pares ordenados $(A,B)$ con $A \in \cat$ y $B \in \mathcal{D}$.
Los morfismos, composición e identidad se definen a manera análoga por componentes.
\end{example}

Podemos definir producto $n$-ario de objetos como el límite de un diagrama con una categoría índice discreta (es decir, sin morfismos a parte de los morfismos identidad) de $n$ objetos.
\begin{remark}\mbox{}
\begin{itemize}
  \item Si existen productos binarios, entonces existe cualquier produco $n$-ario con $n \geq 2$.
  \item En el caso particular de $n=1$, el $1$-producto de cualquier objeto es precisamente el mismo objeto.
  \item En el caso particular de $n=0$, el $0$-producto es precisamente el objeto terminal.
\end{itemize}
\end{remark}

Por esta razón, cuando una categoría tiene productos binarios y objeto terminal, se dice que tiene \emph{todos los productos finitos}.

Hemos visto el producto y el coproducto como casos particulares de límites.
Otros límites importantes son:
\begin{definition}
Dado un diagrama \newterm{span}
\[ \begin{tikzcd}
A & B \arrow[l] \arrow[r] & C
\end{tikzcd} \]
sobre una categoría, su colímite se denomina \newterm{pushout}.
\end{definition}

Un uso típico de pushouts está presente en topología:
\begin{example} % https://ncatlab.org/nlab/show/limits+and+colimits+by+example#pullback
Dado un span
\[ \begin{tikzcd}
X & A \arrow[l,"f" above] \arrow[r,"i"] & Y
\end{tikzcd} \]
en $\Top$, donde $i \colon A \to Y$ es una inclusión, entonces el pushout se llama \newterm{espacio de adjunción} y se escribe $X \cup_f Y$.
El espacio de adjunción se corresponde con el espacio cociente de la unión disjunta de $X$ e $Y$ bajo la relación de equivalencia generada por $x \sim f(x)$. 
\end{example}

\begin{definition}
Dado un diagrama \newterm{cospan} (dual de span)
\[ \begin{tikzcd}
A \arrow[r] & B & C \arrow[l]
\end{tikzcd} \]
sobre una categoría, su límite se denomina \newterm{pullback}.
\end{definition}
\begin{definition}
Dado un diagrama de \newterm{pareja paralela}
\[ \begin{tikzcd}
A \arrow[r,bend left] \arrow[r,bend right] & B
\end{tikzcd} \]
sobre una categoría, su límite se denomina \newterm{ecualizador} y su colímite, \newterm{coequalizador}.
\end{definition}

En resumen:

\begin{center}
\begin{tabular}{ c | c | c }
  Forma & Límite & Colímite\\
  \hline
  $\emptyset$ & Objeto terminal & Objeto inicial \\
  Discreta finita & Producto & Coproducto \\
  Span & - & Pushout \\
  Cospan & Pullback & - \\
  Pareja paralela & Ecualizador & Coecualizador
\end{tabular}
\end{center}

\section{Functores continuos}
Claramente un functor envía conos a conos, pero no es cierto que envíe límites a límites en general.

\begin{definition}
Un functor $F \colon \cat \to \mathcal{D}$ se dice que \emph{preserva límites de forma} $\mathcal{I}$ si para todo diagrama $D \colon \mathcal{I} \to \cat$ con cono límite $L = \underset{\longleftarrow}\lim D$, el cono $F L$ es el cono límite del diagrama $F \circ D$.
Se suele expresar como:
\[ F\left(\underset{\longleftarrow}\lim D\right) = \underset{\longleftarrow}\lim \left(F \circ D\right)\]
Análogamente, $F$ se dice que \emph{preserva colímites de forma} $D$ si:
\[ F\left(\underset{\longrightarrow}\lim D\right) = \underset{\longrightarrow}\lim \left(F \circ D\right)\]
\end{definition}

La uso de límites aquí nos recuerda a la definición de funciones continuas de la matemática clásica.
Esto lleva a la definición de functor continuo y cocontinuo:
\begin{definition}
Un functor es \index{functor!(co)continuo}\emph{functor (co)continuo} si preserva (co)límites de cualquier forma pequeña.
\end{definition}
%Mac Lane
%\begin{theorem}
%Para una categoria localmente pequeña $\cat$ y un objeto $A \in \cat$, el functor $\cat(A,-)$ es continua.
%\end{theorem}
%\begin{proof}
%Sea $D \colon \mathcal{I} \to \cat$ un diagrama pequeño cualquiera con cono límite $\underset{\longleftarrow}\lim D$ formado por un vértice $V$ y morfismos 
%\end{proof}

En algunos contextos, resulta más útil debilitar la definición de functor continuo a diagramas de forma $\omega = (\mathbb{N}, \leq)$, esto nos lleva a la definición de functor $\omega$-continuo.
Un diagrama de forma $\omega$ se refiere a una cada de morfismos como:
\[ \dots \rightarrow A_3 \rightarrow A_2 \rightarrow A_1 \Rightarrow A_0 \]
En estos casos, se suele identificar el diagrama con la sucesión $\{A_n\}_{n \in \mathbb{N}}$, de manera que el límite se escribe:
\[ \underset{\longleftarrow}\lim A_i\]
\begin{definition}
Un functor es $\omega$\emph{-(co)continuo} si preserva (co)límites de forma $\omega$.
\end{definition}
\begin{example}
Dado un primo $p$, los enteros $p$-ádicos se definen como el límite del diagrama:
\[ \dots \rightarrow \mathbb{Z}/p^3\Z \rightarrow \mathbb{Z}/p^2\Z \rightarrow \mathbb{Z}/p\Z \]
en la categoría de anillos.
\end{example}

\section{Transformaciones naturales}
\begin{definition}
Una transformación natural $\mu$ entre dos functores $F, G \colon \cat \to \mathcal{D}$ es una colección de morfismos
\[ \mu_A \colon F A \to G A \]
donde $A \in \cat$ tal que para todo $f \colon A \to B$ el diagrama:
\[
\begin{tikzcd}
F A \arrow[r,"\mu_A"] \arrow[d,"F f" left] & G A \arrow[d,"G f"]\\
F B \arrow[r,"\mu_B"] & G B
\end{tikzcd}
\]
conmuta.
\end{definition}

Usaremos la notación $\mu \colon F \Rightarrow G$ para una transformación natural $\mu$.
Llamamos $\mu_A$ \newterm{componente} de $\mu$ en $A$.
La conmutatividad del diagrama se denomina \emph{propiedad de naturalidad} y es equivalente a:
\[ G f \circ \mu_A = \mu_B \circ F f \]
para todo morfismo $f \colon A \to B$ en $\cat$.

Hay dos formas de componer transformaciones naturales.
\begin{definition}
Dado dos transformaciones naturales $\mu \colon F \Rightarrow G$ y $\eta \colon G \Rightarrow H$ donde $F,G,H \colon \cat \to \mathcal{D}$ son functores, su composición horizontal $\eta \circ \mu \colon F \Rightarrow H$ viene dada por
\[ (\eta \circ \mu)_A = \eta_A \circ \mu_A \]
para todo objeto $A \in \cat$.
\end{definition}
\[ \begin{tikzcd}{\cat} \arrow[r,"F", bend left=100, ""{name=U}] \arrow[r,"G", pos=0.2,""{name=M, pos=0.5,below},""{name=M', pos=0.5,above}] \arrow[r,"H" below, bend right=100, ""{name=D, below}] & \mathcal{D}\\
\arrow[Rightarrow, from=U, to=M, "\mu"] \arrow[Rightarrow, from=M', to=D, "\eta"]\end{tikzcd}\]

\begin{lemma}\label{functor-categoria}
Dados dos categorías $\cat$ y $\mathcal{D}$, existe una categoría donde los objetos son functores $\cat \to \mathcal{D}$ y los morfismos son transformaciones naturales.

Denotamos dicha categoría como $\mathcal{D}^\cat$ ó $[\cat,\mathcal{D}]$.
\end{lemma}
\begin{proof}
Vemos primero que podemos definir una transformación natural identidad $\iota \colon F \Rightarrow F$ dado por $\iota_A = \id_{F A}$ para todo $A \in \cat$.
Por otro lado, que la composición de transformaciones naturales es asociativa es trivial.
\end{proof}

% Milewski
Nos interesa ahora definir una composición de transformaciones naturales de la forma:
\begin{equation}\label{ver-comp} \begin{tikzcd}{\cat} \arrow[r,"F", bend left, ""{name=FU}] \arrow[r,"G" below, bend right, ""{name=FD, below}] & \mathcal{D} \arrow[r,"H",bend left, ""{name=GU}] \arrow[r,"K" below, bend right, ""{name=GD, below}] & \mathcal{E}
\arrow[Rightarrow, from=FU, to=FD, "\mu"] \arrow[Rightarrow, from=GU, to=GD, "\eta"]\end{tikzcd}\end{equation}
Nuestro objeto será definir una transformación natural que vaya de $H \circ F$ a $G \circ K$.
%Riehl/Peter Selinger: Introduction to categorical logic. pdf, page 41
Para ello necesitaremos describir dos formas en las que se pueden componer un functor y una transformación natural:
\begin{definition}
Si $F \colon \cat \to \mathcal{D}$ y $G, H\colon \mathcal{D} \to \mathcal{E}$ son functores y $\mu \colon G \Rightarrow H$ es una transformación natural, el \newterm{whiskering izquierdo}:
\[ \mu \circ F \colon G \circ F \Rightarrow H \circ F \]
está definido como:
\[ (\mu \circ F)_A = \mu_{F A} \]
\end{definition}
La naturalidad de $(\mu \circ F)$ es consecuencia de la naturalidad de $\mu$.

Se suele eliminar $\circ$ y escribir sencillamente $\mu F$.

Por otro lado:
\begin{definition}
Si $F, G \colon \cat \to \mathcal{D}$ y $H\colon \mathcal{D} \to \mathcal{E}$ son functores y $\mu \colon F \Rightarrow G$ es una transformación natural, el \newterm{whiskering derecho}:
\[ H \circ \mu  \colon H \circ F \Rightarrow H \circ G \]
está definido como:
\[ (H \circ \mu)_A = H(\mu_A) = H\mu_A \]
\end{definition}
Aquí la naturalidad no es tan evidente.
\begin{proposition}
El \emph{whiskering} derecho es una transformación natural.
\end{proposition}
\begin{proof}
Por la naturalidad de $\mu$, se da la igualdad
\[ G f \circ \mu_A = \mu_B \circ F f \]
aplicando $H$ y su propiedad de functorialidad:
\[ H(G f) \circ H\mu_A = H\mu_B \circ H(F f) \]
Lo que prueba la naturalidad de $H \circ \mu$.
\end{proof}
Se suele escribir $H\mu$ en lugar de $H \circ \mu$.

Con esto, ya podemos definir la composición horizontal o composición de Godement.
\begin{definition}
Sean $\cat$, $\mathcal{D}$ y $\mathcal{E}$ tres categorías.
Consideramos los functores $F$, $G$, $H$ y $K$, y las transformaciones naturales $\mu$ y $\eta$ en la configuración dada en \ref{ver-comp}.
Definimos la composición horizontal $\eta * \mu \colon H \circ F \Rightarrow K \circ G$ como:
\[ (\eta * \mu)_A = \eta_{G A} \circ H\mu_A \]
\end{definition}
\begin{proposition}
La composición de horizontal $\eta * \mu$ es una transformación natural.
\end{proposition}
%Riehl
\begin{proof}
Por la naturalidad de $\mu$ y $\eta$ se tiene que cada cuadrado del siguiente diagrama es conmutativo.
\[\begin{tikzcd}
{H(F A)} \arrow[r,"H\mu_A"] \arrow[d,"H(F f)"] & {H(G A)} \arrow[r,"\eta_{G A}"] \arrow[d,"H(G f)"] & {K(G A)} \arrow[d,"K(G f)"]\\
{H(F B)} \arrow[r,"H\mu_A"] & {H(G B)} \arrow[r,"\eta_{G B}"] & {K(G B)}
\end{tikzcd}\]
Luego, componiendo horizontalmente, tenemos que es conmutativo el diagrama:
\[\begin{tikzcd}
{H(F A)} \arrow[rr,"\eta_{G A} \circ H\mu_A"] \arrow[d,"H(F f)"] & & {K(G A)} \arrow[d,"K(G f)"]\\
{H(F B)} \arrow[rr,"\eta_{G B} \circ H\mu_A"] & & {K(G B)}
\end{tikzcd}\]
Esto demuestra la naturalidad de $\eta * \mu$.
\end{proof}

Véase que la composición horizontal se puede ver como una composición vertical tras aplicar un \emph{whiskering} apropiado a cada transformación natural.

\begin{proposition}
Para una transformación natural $\mu \colon F \Rightarrow G$ y una transformación natural identidad $\iota \colon H \Rightarrow H$:
\[ \iota * \mu = H\mu \]
\[ \mu * \iota = \mu H\]
\end{proposition}
\begin{proof}
\begin{align*}
(\iota * \mu)_A & = \iota_{G A} \circ F\mu_A\\
& = \id_{H (G A)} \circ H\mu_A\\
& = H\mu_A
\end{align*}
Por otro lado:
\begin{align*}
(\mu * \iota)_A & = \mu_{H A} \circ G\iota_A\\
& = \mu_{H A} \circ G\id_{H A}\\
& = \mu_{H A} \circ \id_{G(H A)}\\
& = \mu_{H A}\\
& = (\mu H)_A
\end{align*}
\end{proof}

\section{Functores adjuntos}
Los functores adjuntos son, en esencia, una forma débil de inversa de functores.
Antes de entrar formalmente en ellos, veamos un par de ejemplos que ilustren la noción que formalizaremos.

\begin{example}
Consideremos el caso de dos conjuntos pre-ordenados $\cat$ y $\mathcal{D}$.
Podemos verlos como categorías, donde los objetos son los elementos del conjunto y hay un morfismo $A \to B$ si $A \leq B$.
Una funcion $F \colon \cat \to \mathcal{D}$ que mantiene el orden puede ser visto sencillamente como un functor sobre estas categorías.

Un functor $G \colon \mathcal{D} \to \cat$ es un \newterm{adjunción derecha} a $F$ si, para todo $A \in \cat$ y $B \in \mathcal{B}$:
\[ F A \leq B \sii A \leq G B \]
\end{example}

\begin{example}
Sea $U \colon \Grp \to \Set$ el functor natural de grupos a conjuntos y sea $F \colon \Set \to \Grp$ el functor que asocia a cada conjunto su correspondiente grupo libre.
\end{example}

\begin{definition}
Una \newterm{adjunción} entre categorías $\cat$ y $\mathcal{D}$ son functores
\[ F \colon \cat \to \mathcal{D} \qquad U \colon \mathcal{D} \to \cat \]
y una transformación natural:
\[ \eta \colon \Id_\cat \Rightarrow U \circ F \]
tal que para todo $A \in \cat$, $B \in \mathcal{D}$ y $f \colon A \to U B$, existe un único $f^* \colon F A \to B$ tal que el siguiente diagrama conmuta:
\[
\begin{tikzcd}
U (F A) \arrow[dr,"U f^*"]\\
& U B\\
A \arrow[ur,"f"] \arrow[uu,"\eta_A"]
\end{tikzcd}
\]
\end{definition}

Llamamos $F$ \newterm{adjunta izquierda}, $U$ \newterm{adjunta derecha} y $\eta$ es la \newterm{unidad} de la adjunción.

\chapter{Lema de Yoneda}

El lema de Yoneda es uno de los resultados más importante, pues el relacionado embebimiento de Yoneda es una herramienta poderosa para demostrar otros resultados.

En este capítulo, siempre estaremos trabajando con categorías localmente pequeñas.

\section{Hom-Functores}
Consideremos la categoría de functores de una categoría $\cat$ a $\Set$, que podemos denotar como $\Set^\cat$.
En esta categoría, los objetos son functores y los morfismos son transformaciones naturales entre functores.

Como estamos bajo la hipótesis que $\cat$ es localmente pequeña, entonces $C(A,B)$ es un conjunto para todo $A \in \cat$ y $B \in \cat$.
Entonces, $C(A,B) \in \Set$.
De este hecho, podemos crear el functor contravariante:
\[ C(A,-) \colon \cat \to \Set \]
que a cada objeto $X \in \cat$ le asocia el conjunto $C(A,X)$.
A cada morfismo $f \colon X \to Y$ en $\cat$, $C(A,f)$ será un morfismo entre los conjuntos $C(A,X)$ y $C(A,Y)$.
La forma natural de asociar estos conjuntos es por la composición $g \mapsto f \circ g$.
A dicho functor le damos el nombre de \newterm{hom-functor}.

Veamos que el hom-functor es realmente un functor.

\[ C(A,\id_B)(g) = g \circ \id = g \Rightarrow C(A,\id_B) = \id_{C(A,B)} \]
\begin{align*}
C(A,g \circ f)(h) & = (g \circ f) \circ h = g \circ (f \circ h)\\
& = g \circ C(A,f)(h) = C(A,g)(C(A,f)(h))\\
& = C(A,g) \circ C(A,f)\ (h)
\end{align*}

Luego $C(A,-)$ respeta el morfismo unidad y la composición de morfismos, luego es efectivamente un functor de $\cat \to \Set$.
Equivalentemente, tenemos que $C(A,-)$ es un objeto de $\Set^\cat$.

Digamos que tenemos un objeto isomorfo a $C(A,-)$ en $\Set^\cat$.
Esto quiere decir que entre el objeto, visto como un functor, y $C(A,-)$ hay una transformación natural invertible, que también llamamos \newterm{isomorfismo natural}.
De aquí procede la siguiente definición: 

\begin{definition}
Un functor $F \colon \cat \to \Set$ es \newterm{representable} si es isomorfo naturalmente a un hom-functor.
\end{definition}

Es decir, un functor representable puede identificarse con $C(A,-)$ para algún $A$.

\subsection{Functores representables en Haskell}
% Milewski
En la categoría $\Hask$, el hom-functor recibe a menudo el nombre de \code{Reader}
\begin{minted}{haskell}
type Reader a x = a -> x
\end{minted}
Es decir, $C(A,-)$ es equivalente a \code{Reader a}, que es equivalente a \code{(->) a}.
Para que un functor \code{F} sea representable necesitamos una transformación natural invertible a \code{Reader a}, es decir, necesitamos:
\begin{minted}{haskell}
functorAreader :: f x -> (a -> x)
readerAfunctor :: (a -> x) -> f x
\end{minted}
tal que cada una sea la inversa de la otra.

Vamos a tomar de la librería para Haskell \textit{adjunctions} de Edward Kmett la siguiente implementación de functores representables:
\begin{minted}{haskell}
class (Functor f) => Representable f where
  type Rep f :: *
  index :: f x -> Rep f -> x
  tabulate :: (Rep f -> x) -> f x
\end{minted}
% tabulate = f
% \end{minted}
Nuestra función \code{functorAreader} es aquí \code{index}, \code{readerAfunctor} se convierte en \code{tabulate}.
El tipo \code{a} pasa a depender del functor \code{f} a través de \code{Rep f}.
Además, se establece que se deben cumplir:
\begin{minted}{haskell}
tabulate . return = return
tabulate . index  = id
index . tabulate  = id
\end{minted}
Las primera condición establece que \code{tabulate} sea una transformación natural. 
Las otras dos condiciones son equivalentes a dicha transformaión natural sea invertible con \code{index}.

\section{Inmersión de Yoneda}
Primero definamos qué es un inmersión.

Recordemos de la definición de functor, que un functor consistía en un par $F_O$ y $F_M$ que actúan sobre los objetos y morfismos respectivamente.
Dado un functor $F \colon \cat \to \mathcal{D}$ y dos objetos $A, B \in \cat$, denotamos por $F_M|_{\cat(A,B)}$ o, sencillamente, $F_{A,B}$ a la \textquote{restricción} de $F_M$ a la colección de morfismos $\cat(A,B)$.
Como $F_M$ respeta el dominio y codominio, tenemos que $F_{A,B}$ es una aplicación:
\[ F_{A,B} \colon \cat(A,B) \to \mathcal{D}(F A, F B) \]
Con esto en mente, definimos las siguientes clases de functores:

\begin{definition}
Un functor $F \colon \cat \to \mathcal{D}$ es 
\begin{itemize}
  \item \index{functor!lleno}\emph{lleno} si para cada $A,B \in \cat$, $F_{A,B}$ es sobreyectiva.
  \item \index{functor!fiel}\emph{fiel}, si para cada $A,B \in \cat$, $F_{A,B}$ es inyectiva.
  \item \index{functor!{inyectivo en objetos}}\emph{inyectivo en objetos} si $F_O$ es inyectivo.
\end{itemize}
\end{definition}

Obsérvese que no es lo mismo que $F$ sea lleno o fiel a que $F_M$ sea inyectiva y sobreyectiva.
Podríamos decir que la propiedad de ser lleno y fiel es una propiedad \textquote{local}.

\begin{definition}
Un functor es una \newterm{inmersión} si es fiel e inyectivo en objetos.
Si además es lleno, decimos que es una \newterm{inmersión llena}. 
\end{definition}

\begin{definition}
Dada una categoría $\cat$, una \newterm{subcategoría} es un par $(\mathcal{D}, F)$ donde $\mathcal{D}$ es una categoría y $F \colon \mathcal{D} \to \cat$ es una inmersión.

Si además, $F$ es llena, decimos que $(\mathcal{D}, F)$ es una \index{subcategoría!llena}\emph{subcategoría llena}.
\end{definition}

\begin{lemma}[Lema de Yoneda]
Sea $\cat$ una categoría localmente pequeña, un functor $F \colon \cat \to \Set$ y un objeto $A \in \cat$.
Denotemos por $Nat(\cat(A,-), F)$ a la colección de transformaciones naturales de $\cat(A,-) \Rightarrow F$.
Hay una biyección:
\[ Nat(\cat(A,-), F) \cong F A \]
que es natural en $A$ y en $F$.
\end{lemma}
% Category theory in context + Awodey
Vamos a precisar:
\begin{itemize}
  \item Hemos visto previamente que $\cat(A,-) \colon \cat \to \Set$ es un functor, luego puede haber una colección de transformaciones naturales de $\cat(A,-)$ al functor $F \colon \cat \to \Set$.
  \item  En la categoría de functores $\Set^{\cat}$, donde $\cat(A,-)$ y $F$ son objetos, $Nat(\cat(A,-),F)$ es precisamente la colección de morfismos $\Set^{\cat}(\cat(A,-),F)$.
  \item La naturalidad en $F$ quiere decir que para toda transformación natural $\theta \colon F \Rightarrow G$, se tiene que el siguiente diagrama es conmutativo:
\[
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\cong"] \arrow[dd,"{Nat(\cat(A,-),\theta)}" left] & & F A \arrow[dd,"\theta_A"]\\
  &\\
  {Nat(\cat(A,-),G)} \arrow[rr,"\cong"] & & G A
\end{tikzcd}
\]
  \item La naturalidad en $A$ quiere decir que para todo $f \colon A \to B$, se tiene que el siguiente diagrama conmuta:
  \[
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\cong"] \arrow[dd,"{Nat(\cat(f,-),F)}" left] & & F A \arrow[dd,"F f"]\\
  &\\
  {Nat(\cat(B,-),F)} \arrow[rr,"\cong"] & & F B
\end{tikzcd}
\]
  donde para una transformación natural $\mu \colon \cat(A,-) \Rightarrow F$ y morfismo $h \colon B \to C$:
  \[ (Nat(\cat(f,-),F)\mu)_C(h) = \mu_C \circ \cat(f,C)(h) = \mu_C (h \circ f) \]
\end{itemize}
\begin{proof}
Primero miramos que para una transformación natural $\mu \in Nat(\cat(A,-),F)$, es decir, $\mu \colon \cat(A,-) \Rightarrow F$, su componente en $A \in \cat$ es una función entre conjuntos
\[ \mu_A \colon \cat(A,A) \to F A \]
Sabemos además que $\cat(A,A)$ es un conjunto no vacío, pues al menos contiene $\id_A$

Consideramos la función $\phi \colon Nat(\cat(A,-),F) \to F A$ definida por:
\begin{align*}
  \phi \colon Nat(\cat(A,-),F) & \to F A\\
  \alpha & \mapsto \alpha_A(\id_A)
\end{align*}

Dado cualquier $x \in F A \in \Set$, definimos la transformación natural 
\[ \psi(x) \colon \cat(A,-) \Rightarrow F \]
estableciendo su componente para $B \in \cat$ cualquiera:
\begin{align*}
  \psi(x)_B \colon \cat(A,B) & \to F B\\
  \psi(x)_B (f) & \mapsto (F f)(x)
\end{align*}

Veamos que $\psi(x)$ cumple la naturalidad. Para un $f \colon B \to C$:
\begin{equation}\label{psi-diagrama}
\begin{tikzcd}
  {\cat(A,B)} \arrow[rr,"\psi(x)_B"] \arrow[dd,"{\cat(A,f)}"] & & F B \arrow[dd,"F f"]\\
  &\\
  {\cat(A,C)} \arrow[rr,"\psi(x)_C"] & & F C
\end{tikzcd}
\end{equation}
Tenemos que para todo $h \colon A \to B$:
\begin{align*}
(\psi(x)_C \circ \cat(A,f)) (h) & = \psi(x)_C (f \circ h)\\
& = (F (f \circ h))(x)\\
& = (F f) \circ (F h)(x)\\
& = (F f)(\psi(x)_B(h))\\
& = (F f) \circ (\psi(x)_B)(h)
\end{align*}
Luego el diagrama \ref{psi-diagrama} conmuta.

Veamos que $\phi$ y $\psi$ son inversas. Para $x \in F A$:
\begin{align*}
 \phi(\psi(x)) & = \psi(x)_A(\id_A)\\
 & = (F (\id_A))(x)\\
 & = \id_{F A}(x) & \text{por definición de functor}\\
 & = x
\end{align*}
Para $\mu \colon \cat(A,-) \Rightarrow F$, $B \in \cat$ y $h \colon A \to B$:
\begin{align*}
 \psi(\phi(\mu))_B(h) & = \psi(\mu_A(\id_A))_B(h)\\
 & = (F h)(\mu_A(\id_A))\\
 & = (\mu_B)(C(A,h)(\id_A)) & \text{por naturalidad de }\mu\\
 & = \mu_B(h\circ \id_A)\\
 & = \mu_B(h)
\end{align*}
Luego $\phi$ y $\psi$ son inversas y $Nat(\cat(A,-),F) \cong F A$.
Veamos la naturalidad en $F$ y en $A$:
\begin{equation}\label{diagrama-F}
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\phi_F"] \arrow[dd,"{Nat(\cat(A,-),\theta)}" left] & & F A \arrow[dd,"\theta_A"]\\
  &\\
  {Nat(\cat(A,-),G)} \arrow[rr,"\phi_G"] & & G A
\end{tikzcd}
\end{equation}
Sea $B \in \cat$ y $\mu \colon \cat(A,-) \Rightarrow F$:
\begin{align*}
 \theta_A(\phi_F(\mu)) & = \theta_A(\mu_A(\id_A))\\
 & = (\theta \circ \mu)_A(\id_A)\\
 & = \phi_G(\theta \circ \mu)
\end{align*}
que demuestra que el diagrama \ref{diagrama-F} conmuta.

Sea $f \colon A \to B$ y $\mu \colon \cat(A,-) \Rightarrow F$:
\begin{equation}\label{diagrama-A}
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\phi_A"] \arrow[dd,"{Nat(\cat(f,-),F)}" left] & & F A \arrow[dd,"F f"]\\
  &\\
  {Nat(\cat(B,-),F)} \arrow[rr,"\phi_B"] & & F B
\end{tikzcd}
\end{equation}
\begin{align*}
 (F f)(\phi_A(\mu)) & = (F f)(\mu_A(\id_A))\\
 & = (\mu_B)(C(A,f)(\id_A)) & \text{por naturalidad de }\mu\\
 & = (\mu_B)(f \circ \id_A)\\
 & = (\mu_B)(\id_B \circ f)\\
 & = (\mu_B)(C(f,B)(\id_B))\\
 & = (\mu \circ C(f,-))_B(\id_B)\\
 & = (\phi_B)(\mu \circ C(f,-))
\end{align*}
que demuestra que el diagrama \ref{diagrama-A} conmuta y acaba la demostración.
\end{proof}

\begin{remark}
Considerando la categoría opuesta, se tiene que para todo objeto $A \in \cat$ y functor contravariante $F \colon \cat^{op} \to \Set$ hay una biyección
\[ Nat(\cat(-,A), F) \cong F A\]
natural en $A$ y $F$.
\end{remark}

Nuestra primera aplicación del lema de Yoneda es usando $F = \cat(B,-)$.
Se tiene que:
\[ Nat(\cat(A,-),\cat(B,-)) \cong \cat(B,A) \]
Análogamente:
\[ Nat(\cat(-,A),\cat(-,B)) \cong \cat(A,B) \]
Esto motiva la inmersión de Yoneda:
\begin{definition}
Las \index{inmersión de Yoneda}\emph{inmersiones de Yoneda} covariante y contravariante son los morfismos:
\begin{align*} 
  Y \colon \cat & \to \Set^{\cat^{op}}\\
  A & \mapsto \cat(-,A)\\
  f \colon A \to B & \mapsto \cat(-,f) \colon \cat(-,A) \to \cat(-,B)
\end{align*}
\begin{align*} 
  K \colon \cat^{op} & \to \Set^{\cat}\\
  A & \mapsto \cat(A,-)\\
  f \colon A \to B & \mapsto \cat(f,-) \colon \cat(B,-) \to \cat(A,-)
\end{align*}
es decir, las \index{currificación}currificaciones del bifunctor $\cat(-,-) \colon \cat^{op} \times \cat \to \Set$.
\end{definition}
Obsérvese que $K$ es un functor contravariante y que $K A$ es un functor covariante $\cat^{op} \to \Set$.
Análogamente, $Y$ es un functor covariante a los functores contravariantes $\cat^{op} \to \Set$.

Veremos ahora que el uso de \textquote{inmersión} está justificado:
\begin{proposition}
Las inmersiones de Yoneda son inmersiones llenas.
\end{proposition}
\begin{proof}
Lo probamos para $Y$.
La inyectividad sobre objetos es evidente.
Observamos que, por definición, $\cat(A,B) = (Y B)A$.
Aplicando el lema de Yoneda:
\[ \cat(A,B) = (Y B)A \cong \Set^{\cat^{op}}(Y A, Y B)\]
Luego $Y$ es inmersión llena.
La prueba para $K$ es análoga.
\end{proof}

Un functor contravariante en $\Set^{\cat^{op}}$ recibe el nombre de \newterm{prehaz}.
Una consecuencia de la anterior proposición es que toda categoría localmente pequeña es una subcategoría llena de la categoría de prehaces.

\section{Referencias}
\begin{itemize}
  \item Milewski, B. (2014). \emph{Category Theory for Programmers}, Capítulos 14-16.
  \item Riehl, E. (2014). \emph{Category Theory in Context}, Capítulo 2.
  \item Awodey, S. (2006). \emph{Category Theory}, Capítulo 8. 
\end{itemize}
\chapter{Categorías cartesianamente cerradas}
\section{Exponencial}
Si $\cat$ tiene productos binarios, entonces el \newterm{exponencial} de los objetos $B$ y $C$ de $\cat$ es el objeto
\[ C^B \]
y un morfismo:
\[ \varepsilon \colon C^B \times B \to C \]
tal que para todo objeto $A$ y morfismo
\[ f \colon A \times B \to C \]
hay un único morfismo
\[ \lambda_f \colon A \to C^B \]
tal que el siguiente diagrama conmuta:

\[
\begin{tikzcd}
C^B \times B \arrow[rr,"\varepsilon"] & & C \\\\
A \times B \arrow[uu,"\lambda_f\times\id_A"]  \arrow[uurr,"f"]
\end{tikzcd}
\]

El morfismo $\varepsilon$ se denomina \newterm{evaluación}.
El morfismo $\lambda_f$ se denomina \newterm{transposición} o \newterm{currificación} de $f$.

Obsérvese que
\begin{align*}
\lambda \colon C(A \times B, C) & \to C(A,C^B)\\
f & \mapsto \lambda_f
\end{align*}
es un isomorfismo por la existencia e unicidad de $\lambda_f$ por cada $f$.

En programación funcional, la currificación resulta de gran utilidad.
En Haskell, por ejemplo, se usa la función \code{curry} de tipo:
\begin{minted}{haskell}
curry :: ((a, b) -> c) -> a -> b -> c
\end{minted}
Su inversa es \code{uncurry}, de tipo:
\begin{minted}{haskell}
uncurry :: (a ->  b -> c) -> (a, b) -> c
\end{minted}
% a = b
% \end{minted}

\section{Categorías cerradas cartesianas}
\begin{definition}
Decimos que una categoría es \index{categoría!cartesianamente cerrada}\emph{cartesianamente cerrada} si cumple las siguientes condiciones:
\begin{enumerate}
\item Tiene productos finitos.
\item Tiene el exponencial de dos objetos cualesquiera.
\end{enumerate}
Si además tiene coproductos finitos, se denomina \index{categoría!bicartesianamente cerrada}\emph{bicartesianamente cerrada}
\end{definition}

\begin{example}
Consideramos la categoría $Pos$ de conjuntos parcialmente ordenados donde los morfismos son funciones monótonas del que hablamos en \ref{ejemplo-producto-pos}.
Sean $P$ y $Q$ posets, veamos que $Q^P = \{ f \colon Q \to P \mid f \text{ monótona}\}$ con el orden:
\[ f \leq g \sii f(p) \leq g(p) \text{ para todo }p \in P \]
El morfismo evaluación es:
\[ \varepsilon (f,p) = f(p) \]
Veamos que efectivamente $\varepsilon$ es un morfismo.
Supongamos que $(f,p) \leq (f',p')$, entonces:
\begin{align*}
\varepsilon(f,p) & = f(p) & \\
& \leq f(p') & \text{ por ser }f\text{ monótona y }p\leq p'\\
& \leq f'(p') & \text{ por ser }f \leq f'\\
& = \varepsilon(f',p')
\end{align*}
Luego $\varepsilon$ es un morfismo $Pos$.
Sea $f \colon X \times P \to Q$ monótona y sea $x \leq x'$.
\begin{align*}
\lambda_f(x)(p) & = f(x,p) & \\
& \leq f(x',p) & \text{pues }(x,p) \leq (x',p)\\
& \leq f'(x',p) & \text{pues }f \leq f'\\
& = \lambda_f(x')(p)
\end{align*}
\end{example}

\begin{lemma}
En una categoría cartesianamente cerrada $\cat$, la exponenciación por un objeto fijo es un functor.
\end{lemma}
\begin{proof}
Queremos probar que la exponenciación:
\[ -^Z \colon \cat \to \cat \]
para un objeto fijo $Z$ es un endofunctor.
Como $\cat$ es cartesianamente cerrada, la exponenciación de $A^Z$ está bien definida para todo objeto $A$ de $\cat$.
Consideremos ahora un morfismo $f \colon A \to B$, tenemos que definir $f^Z \colon A^Z \to B^Z$.
Primero observamos que:
\[ \varepsilon \colon A^Z \times Z \to A \]
Luego:
\[ f \circ \varepsilon \colon A^Z \times Z \to B\]
Transponiendo:
\[ \lambda_{f \circ \varepsilon} \colon A^Z \to B^Z \]
Así que definimos $f^Z$ como $\lambda_{f \circ \varepsilon}$.

Tenemos el siguiente diagrama conmutativo consecuencia de la transposición:
\[
\begin{tikzcd}
B^Z \times Z \arrow[rr,"\varepsilon"] & & B \\\\
A^Z \times Z \arrow[uu,"\lambda_{f\circ \varepsilon}\times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]

Luego considerando $(\id_A)^Z$:
\[
\begin{tikzcd}
A^Z \times Z \arrow[rr,"\varepsilon"] & & A \\\\
A^Z \times Z \arrow[uu,"(\id_A)^Z\times\id_Z"]  \arrow[uurr,"\varepsilon"]
\end{tikzcd}
\]
Como $\id_{A^Z}$ cumple también el anterior diagrama y tenemos que el morfismo que cumple el diagrama es único, $(\id_A)^Z = \id_{A^Z}$.

Por otro lado, si tenemos morfismos: $f \colon A \to B$ y $g \colon B \to C$, tenemos que $(g \circ f)^Z$ es el único que conmuta el diagrama:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C \\\\
A^Z \times Z \arrow[uu,"(g \circ f)^Z \times\id_Z"]  \arrow[uurr,"g \circ f \circ \varepsilon"]
\end{tikzcd}
\]
Sin embargo, observamos que también conmuta:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
B^Z \times Z \arrow[rr,"\varepsilon"] \arrow[uu,"g^Z \times \id_Z"] \arrow[uurr,"g \circ \varepsilon"] & & B \\\\
A^Z \times Z \arrow[uu,"f^Z \times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]
Podemos reemplazar la flecha diagonal $g \circ \varepsilon$ obteniendo:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
B^Z \times Z \arrow[rr,"\varepsilon"] \arrow[uu,"g^Z \times \id_Z"] & & B \arrow[uu,"g"] \\\\
A^Z \times Z \arrow[uu,"f^Z \times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]
Finalmente, este diagrama implica que:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
A^Z \times Z \arrow[uu,"(g^Z \circ f^Z) \times\id_Z"]  \arrow[uurr,"g \circ f \circ \varepsilon"]
\end{tikzcd}
\]
conmuta, luego prueba por unicidad que $(g \circ f)^Z = g^Z \circ f^Z$.

Esto demuestra que $-^Z$ es un endofunctor.
\end{proof}

%Más atrás, consideramos la categoría de functores entre dos categorías $\cat$ y $\mathcal{D}$.
%Consideramos ahora la \index{categoría!{de categorías pequeñas}}\emph{categoría de categorías pequeñas}, denominada \index{Cat@$\Cat$|see {categoría de categorías pequeñas}}$\Cat$, con functores como morfismos.

% TODO: Vamos a ver que $\Cat$ es cartesianamente cerrada.

\section{Lógica}
\begin{definition}
Un \newterm{sistema deductivo} es un grafo:
\begin{enumerate}
\item Con flechas $A \xrightarrow{1_A} A$
\item Con una operación binaria sobre flechas $A \xrightarrow{1_A} A$:

\AxiomC{$A \xrightarrow{f} B$}
\AxiomC{$B \xrightarrow{g} C$}
\BinaryInfC{$A \xrightarrow{gf} C$}
\DisplayProof
\end{enumerate}
\end{definition}

Los nodos de los grafos de un sistema deductivo se denominan \emph{fórmulas} y las flechas, \emph{pruebas}.

Hasta aquí es evidente que el concepto de sistema deductivo es equivalente a categoría.

\begin{definition}
Un \newterm{cálculo de conjunción} es un sistema deductivo donde existe una fórmula $T$ (de \emph{True}), una operación binaria $\land$ llamada conjunción y las siguientes reglas:
\begin{enumerate}
  \item $A \xrightarrow{O_A} T$.
  \item $A \land B \xrightarrow{\pi^1_{A,B}} A$.
  \item $A \land B \xrightarrow{\pi^2_{A,B}} B$.
  \item
  
  \AxiomC{$C \xrightarrow{f} A$}
  \AxiomC{$C \xrightarrow{g} C$}
  \BinaryInfC{$C \xrightarrow{\langle f,g \rangle} A \land B$}
  \DisplayProof
\end{enumerate}
\end{definition}

\begin{proposition}
Una categoría con productos finitos es un cálculo de conjunción donde $T$ es el objeto terminal y $\land$ es el producto de objetos.
\end{proposition}
\begin{proof}
Tomamos $O_A$ como el morfismo $A \to T$.
Igualmente, tomamos $\pi^1$ y $\pi^2$ como las proyecciones del objeto producto $A \times B$ a sus factores.
Para dos morfismo $f \colon C \to A$ y $g \colon C \to B$, sabemos que existe un único morfismo $f \colon C \to A \times B$, que se corresponde con $\langle f,g \rangle$.
\end{proof}

\begin{definition}
Un \newterm{cálculo proposicional intuicionista positivo} es un cálculo de conjunción con una operación binaria $\Rightarrow$ sobre fórmulas y:
\begin{enumerate}
\item $(A \Rightarrow B) \land A \xrightarrow{\varepsilon_{A,B}} B$.
\item 

  \AxiomC{$C \land A \xrightarrow{h} B$}
  \UnaryInfC{$C \xrightarrow{h^*} A \Rightarrow B$}
  \DisplayProof
\end{enumerate} 
\end{definition}
\begin{proposition}
Una categoría cartesianamente cerrada es un cálculo proposicional intuicionista positivo donde $\Rightarrow$ se corresponde con la exponenciación.
\end{proposition}
\begin{proof}
El morfismo $\varepsilon \colon B^A \times A \to B$ de la evaluación de la exponenciación sirve como $\varepsilon_{A,B}$.
Por otro lado $h^*$ se corresponde con la currificación $\lambda_h$.
\end{proof}

\begin{definition}
Una \newterm{cálculo intuicionista} es un cálculo proposicional intuicionista positivo con una fórmula $\bot$, una operación disyunción $\lor$ sobre fórmulas y unas flechas:
\begin{enumerate}
\item $\bot \xrightarrow{!} A$.
\item $A \xrightarrow{\kappa^1_{A,B}} A \lor B$
\item $B \xrightarrow{\kappa^2_{A,B}} A \lor B$
\item 

\AxiomC{$A \xrightarrow{f} C$}
\AxiomC{$B \xrightarrow{g} C$}
\BinaryInfC{$A \lor B \xrightarrow{[f,g]} C$}
\DisplayProof
\end{enumerate}
\end{definition}
\begin{proposition}
Una categoría bicartesianamente cerrada es un cálculo intuicionista donde $\bot$ se corresponde con el objeto inicial y $\lor$ se corresponde con el coproducto.
\end{proposition}
\begin{proof}
Las primera regla es consecuencia de la definición de objeto inicial.
Las otras tres reglas están dadas por las propiedades del coproducto.
\end{proof}

Este vínculo entre lógica intuicionista y categorías bicartesianamente cerradas nos permite movernos entre las dos teorías cuando queramos demostrar algún resultado, por ejemplo:
\begin{lemma}
En cálculo intuicionista proposicional hay como mucho una demostración $A \to \bot$ salvo equivalencia de pruebas.
\end{lemma}
\begin{proof}
En una categoría bicatersianamente cerrada $\cat$ con objeto inicial $0$, para cualquier par de objetos $A$ y $B$ cualesquiera:
\[ \cat(0 \times A, B) \cong \cat(0, B^A) \]
Como hay un único morfismo en $\cat(0, B^A)$ por ser $0$ inicial, entonces hay un único morfismo $0 \times A \to B$.
Luego $0 \times A$ es objeto inicial.
Supongamos que hubiera un morfismo $f \colon A \to 0$.
Como también hay un morfismo $\id_A$, debe haber un morfismo $h \colon A \to 0 \times A$ por la definición de objeto producto.
Si $\pi_2 \colon 0 \times A \to A$ es la segunda proyección, entonces $\pi_2 \circ h = \id_A$ por la definición de producto y $h \circ \pi_2 = \id_{0 \times A}$ porque sólo hay un morfismo $0 \times A \to 0 \times A$.
Por lo tanto $A \cong 0$ y sólo $f$ es el único morfismo.
\end{proof}


Ahora que hemos construyendo en paralelo un sistema lógico intuicionista y una categoría equivalente, nos podemos preguntar si podemos dar un paso más y llegar la lógica clásica.
Para ello hay que añadir el principio del tercero excluso, que es equivalente a la regla de eliminación de doble negación.
Para ello, definimos $\neg A$ como la fórmula $A \Rightarrow \bot$.
\begin{prooftree}
\AxiomC{$\neg \neg A$}
\UnaryInfC{A}
\end{prooftree}
¿Qué ocurriría si hubiera un isomorfismo $\neg \neg A \to A$ en una categoría bicartesianamente cerrada?
Primero observémos que $\neg \neg A$ es equivalente a $0^{0^A}$.

\begin{theorem}
Sea $\cat$ una categoría cartesianamente cerrada con objeto inicial $0$.
Si para todo objeto $A$ se tiene $0^{0^A} \cong A$, entonces $\cat$ es fina, es decir, tiene como mucho un morfismo entre dos objetos.
\end{theorem}
\begin{proof}
Por definición, para objetos $B$ y $C$:
\[ \cat(B, 0^C) \cong \cat(B \times C, 0) \]
Como hay como mucho un morfismo en $\cat(B \times C, 0)$, entonces hay como mucho un morfismo $B \to 0^C$.
Tomando $C = 0^A$, se tiene que hay como mucho un morfismo $B \to 0^{0^A} \cong A$.
\end{proof}

Por lo tanto, cuando añadimos la regla de eliminación de doble negación perdemos la capacidad de distinguir entre distintas pruebas en nuestra categoría.
Esto vuelve poco interesante estudiar categorías de este tipo. 

\section{Referencias}
\begin{itemize}
  \item Awodey, S. (2006). \emph{Category Theory}, Capítulo 6.
  \item Lambek, J. (1986). \emph{Introduction to Higher Order Categorical Logic}, Parte I.
  \item Low, Z.L. (2011). \emph{Bicartesian closed categories and logic}.
\end{itemize}

\chapter{Monoides}
\epigraph{"A monad is a monoid in the category of endofunctors, what's the problem?"}{\textit{A Brief, Incomplete, and Mostly Wrong History of Programming Languages\\James Iry}}
\section{Monoides clásicos}
En álgebra, un \newterm{monoide} $(M,\cdot)$ es un conjunto $M$ junto a una operación binaria $\cdot \colon M \times M \to M$ asociativa y con elemento unidad en $M$.
Una forma alternativa de ver un monoide es como una categoría de un sólo objeto.
Si llamamos $A$ al único objeto de dicha categoría, identificamos los elementos de $M$ con los morfismos $f \colon A \to A$ y la composición de morfismos con la operación binaria.
El elemento identidad se identifica con el morfismo identidad.

Por ejemplo, el monoide $(\mathbb{N},+)$ se corresponde con la categoría:
\[
\begin{tikzcd}
A \arrow[loop right,"0" right] \arrow[loop right,distance=3em,"1" right] \arrow[loop right,distance=5em,"2" right]
\arrow[loop right,distance=7em,"\dots" right]
\end{tikzcd}
\]

A su vez, para cualquier categoría localmente pequeña $\cat$, todo objeto $A \in \cat$ induce un monoide $\cat(A,A)$.

% Milewski
\section{Monoides en Haskell}
En Haskell, los monoides están representando por la siguiente clase:
\begin{minted}{haskell}
class Monoid m where
  mappend :: m -> m -> m
  mempty :: m
\end{minted}
% =
% \end{minted}
donde \code{mappend} debe ser asociativa y \code{mempty} debe ser su elemento unidad.
En Haskell, se suele usar el operador infijo \code{<>} como sinónimo de \code{mappend} para facilitar la lectura.
Un ejemplo de monoide habitual es el de la listas de tipo un tipo cualquiera \code{a} donde \code{mappend} se corresponde con la concatenación.
\begin{minted}{haskell}
> [2,3,4] <> [5,6,7]
[2,3,4,5,6,7]
\end{minted}
La interpretación de un monoide como la estructura de los endomorfismo de un objeto se puede ver aquí cuando aplicamos parcialmente \code{mappend} a un objeto \code{x} de tipo \code{m}:
\begin{minted}{haskell}
mappend x :: m -> m
\end{minted}
Tenemos que \code{mappend x} es un endomorfismo en el tipo \code{m} y que \code{mappend mempty} es equivalente al morfismo identidad.
Es decir \code{mappend} se puede ver como una función que asocia cada elemento del monoide (como grupo) con el endomorfismo correspondiente del monoide (como endomorfismos de \code{m}).

\section{Categorías monoidales}
% Awodey 4
Otra forma de ver monoides en teoría de categorías es através de \index{objeto!monoide}\emph{objeto monoide} en una categoría.

\begin{definition}
Una \index{categoría!monoidal}\emph{categoría monoidal} es una categoría $\cat$ con un bifunctor $\otimes \colon \cat \times \cat \to \cat$ y un objeto unidad $I \in \cat$ con isomorfismos naturales:
\begin{itemize}
  \item El asociador:
\[ \alpha_{ABC} \colon A \otimes (B \otimes C) \Rightarrow (A \otimes B) \otimes C \]
  \item El unidor izquierdo:
\[ \lambda_A \colon I \otimes A \Rightarrow A \]
  \item El unidor derecho:
\[ \rho_A \colon A \otimes I \Rightarrow A \]
\end{itemize}
de manera que cumpla las \index{leyes de coherencia}leyes de coherencia, es decir, que los siguientes diagramas conmuten (entiéndase que estamos tomando las correctas componentes de $\alpha$, $\lambda$ y $\rho$):
\[\begin{tikzcd}
{A \otimes (B \otimes (C \otimes D))} \arrow[r,"\alpha"] \arrow[d,"\id\otimes\alpha"] & {(A \otimes B) \otimes (C \otimes D)} \arrow[r,"\alpha"] & {((A \otimes B) \otimes C) \otimes D}\\
{A \otimes ((B \otimes C) \otimes D)} \arrow[rr,"\alpha"] & & {(A \otimes (B \otimes C)) \otimes D} \arrow[u,"\alpha\otimes\id"]
\end{tikzcd}\]
\[\begin{tikzcd}
{A \otimes (I \otimes C)} \arrow[dr,"\id \otimes \lambda" below] \arrow[rr,"\alpha"] & & {(A \otimes I) \otimes C} \arrow[dl,"\rho \otimes \id"]\\
& {A \otimes C}
\end{tikzcd}\]
y por último:
\[ \lambda_I = \rho_I \]
\end{definition}

% Categorical homotopy Theory Riehl
Un ejemplo sencillo de categoría monoidal es cualquier categoría con productos finitos, tomando $A \otimes B = A \times B$.
Es más, en dicho caso, existe un isomorfismo natural $A \otimes B \cong B \otimes A$.
Una categoría monoidal con dicho isomorfismo natural se denomina \index{categoría!monoidal!simétrica}\emph{categoría monoidal simétrica}.
Por lo tanto, $\Set$ forma una categoría monoidal simétrica con el producto cartesiano y un conjunto unitario cualquiera como identidad del producto.
También, $\Cat$ forma una categoría monoidal simétrica con el producto y una categoría unitaria como $\mathbb{1}$ como identidad del producto.

Veamos otro ejemplo más sofisticado.
% MacLane
\begin{example}
\label{ej-abeliano}
Consideramos la categoría de grupos abelianos $\Ab$.
Para dos grupos $A$ y $B$, definimos $A \otimes B$ como su producto tensorial como $\Z$-módulos.
Más explícitamente, $A \otimes B$ es un grupo abeliano con un producto bilineal $\otimes$ tal que para todo grupo abeliano $C$ y toda aplicación bilineal $f \colon A \times B \to C$, existe un único homomorfismo de grupos $\widetilde{f}$ tal que el siguiente diagrama conmuta:
\[ \begin{tikzcd}{A \times B} \arrow[dr,"f" below] \arrow[r,"\otimes"] & {A \otimes B}\arrow[d,"\widetilde{f}",dashed]\\
& C \end{tikzcd}\]
%Para dos grupos $G$ y $H$, definimos $G \otimes H$ como el cociente del grupo abeliano libre de símbolos $\{g \otimes h \colon g \in G, h \in H\}$ por las relaciones que hagan que la aplicación $\gamma \colon (g,h) \mapsto g \oplus h$ sea bilineal en $G \times H$.
Por la unicidad de la construcción, hay un único isomorfismo natural $\alpha_{ABC} \colon A \otimes (B \otimes C) \to (A \otimes B) \otimes C$.

% Demo propia
Veamos que $\Z$ es el objeto unidad.
Para ello, consideramos una aplicación bilineal $f \colon A \times \Z \to B$ cualquiera.
Definimos la aplicación lineal
\begin{align*}
\phi \colon A \times \Z & \to A\\
\phi \colon (a,n) & \mapsto \overbrace{a + \dots + a}^\text{n veces}
\end{align*}
y el homomorfismo de grupo:
\begin{align*}
\widetilde{f} \colon A & \to B\\
\widetilde{f} \colon a & \mapsto f(a,1)
\end{align*}
Entonces, por linealidad sobre $\Z$:
\[ f(a,n) = f(a,\overbrace{1 + 1 + \dots + 1}^\text{n veces}) = \overbrace{f(a,1) + \dots + f(a,1)}^\text{n veces} = (\widetilde{f} \circ \phi)(a,n)\]
Luego $A \otimes \Z \cong_{\lambda_A} A \cong_{\rho_A} \Z \otimes G$.

Es sencillo comprobar que las leyes de coherencia se cumplen.
%Definimos: 
%\begin{align*}
%\psi \colon G & \to G \otimes \Z\\
%\psi \colon g & \mapsto \overbrace{g + g + \dots + g}^\text{n veces}
%\end{align*}
%Como la aplicación $G \times \Z \to G \otimes \Z$ es lineal sobre $\Z$:
%\[ g\otimes n = g\otimes (\overbrace{1 + \dots + 1}^\text{n veces}) = \overbrace{g \otimes 1 + \dots + g\otimes 1}^\text{n veces}\]
\end{example}

\section{Categorías enriquecidas}
Recordemos que una categoría $\cat$ es localmente pequeña si para todo pares de objetos $A, B \in \cat$, se tiene que $\cat(A,B) \in \Set$.
Una idea esencial en la teoría de categorías de orden superior es el concepto de \index{categoría!enriquecida}\emph{categoría enriquecida}, que consiste en remplazar $\Set$ de la definición anterior con cualquier otra categoría monoidal simétrica.
Informalmente, dada una categoría monoidal simétrica $\mathcal{V}$, una categoría $\cat$ se dice que está $\mathcal{V}$-enriquecida si para cualquier par de objetos $A, B \in \cat$, $\cat(A, B) \in \mathcal{V}$.
A esta definición hay que añadir unas condiciones de compatibilidad con la composición, de las que hablamos a continuación:
%El punto de inicio para la teoría de categorías de orden superior consiste en considerar las categorías $\Cat$-enriquecida, denominadas $2$-categorías.

\begin{definition}
Dada una categoría monoidal simétrica $(\mathcal{V}, \otimes, I)$, una $\mathcal{V}$-categoría $\cat$ consiste en:
\begin{itemize}
  \item Una colección de objetos.
  \item Para cada par de objetos $A, B$ en $\cat$, un objeto llamado \newterm{hom-objeto} $\cat(A,B) \in \mathcal{V}$.
  \item Para cada $A \in \cat$, un morfismo $\Id_A \colon I \to \cat(A,A)$ en $\mathcal{V}$.
  \item Para todo $A, B, C \in \cat$, un morfismo $\circ \colon \cat(B,C) \otimes \cat(A,B) \to \cat(A,C)$ en $\mathcal{V}$.
\end{itemize}
de manera que los siguientes diagramas conmuten:
\[ \begin{tikzcd}
{\cat(C,D) \otimes \cat(B,C) \otimes \cat(A,B)} \arrow[r,"\id\otimes\circ"] \arrow[d,"\circ\otimes\id"]& {\cat(C,D) \otimes \cat(A,C)} \arrow[d,"\circ"]\\
{\cat(B,D) \otimes \cat(A,B)} \arrow[r,"\circ"] & {\cat(A,D)}
\end{tikzcd}\]

\[ \begin{tikzcd}
{\cat(A,B) \otimes I} \arrow[r,"\id\otimes\Id_A"] \arrow[dr,"\cong" below] & {\cat(A,B) \otimes \cat(A,A)} \arrow[d,"\circ"] & {\cat(B,B) \otimes \cat(A,B)} \arrow[d,"\circ"] & {I \otimes \cat(A,B)} \arrow[l,"\Id_B \otimes \id" above] \arrow[dl,"\cong" below]\\
& \cat(A,B) & \cat(A,B)
\end{tikzcd}\]
\end{definition}

\begin{example}\label{cat-2-categoria}
Dotemos ahora a $\Cat$ de estructura de $\Cat$-categoría, es decir, $2$-categoría.

Primero recordemos que $(\Cat, \times, \mathbb{1})$ es una categoría monoidal simétrica.
Por otro lado, para un par de categorías pequeñas $\cat$ y $\mathcal{D}$, los functores $\cat \to \mathcal{D}$ forman una categoría pequeña $\mathcal{D}^\cat$ como comentamos en \ref{functor-categoria}.
En esta categoría, los morfismos entre dos functores $F$ y $G$ eran las transformaciones naturales $F \Rightarrow G$.

Además, consideramos la transformación natural $\Id_A \colon \mathbb{1} \to \cat^\cat$ que asocia el único objeto de $\mathbb{1}$ con el functor identidad.
Por último, para unas categorías cualesquiera $\cat$, $\mathcal{D}$ y $\mathcal{E}$ tenemos que definir un morfismo.
\[ \circ \colon \mathcal{E}^\mathcal{D} \times \mathcal{D}^\cat \to \mathcal{E}^\cat\]
Ojo, un morfismo en $\Cat$ es un functor.
Sea $F \in \mathcal{D}^\cat$ y $G \in \mathcal{E}^\mathcal{D}$, definimos $G \circ F$ como la composición habitual de functores.
Ahora bien, como $\circ$ es functor, debe actuar también sobre los morfismos, que aquí son transformaciones naturales.
Para transformaciones naturales $\mu \colon F \Rightarrow G$ en $\mathcal{D}^\cat$ y $\eta \colon H \Rightarrow K$ en $\mathcal{E}^\mathcal{D}$, basta definir $\eta \circ \mu$ como su composición horizontal.

Con estas definiciones se cumple la conmutatividad de los diagramas de las categoría enriquecidas y deducimos que $\Cat$ es una $2$-categoría.
\end{example}

\section{Monoides}
Volviendo, al tema de los monoides, ahora podemos generalizar el concepto de monoide.
\begin{definition}
Un \index{monoide}\emph{monoide} es un objeto $M$ de una categoría monoidal $(\cat, \otimes, I)$ con dos morfismos:
\begin{tikzcd}
M \otimes M \arrow[r,"\mu"] & M & I \arrow[l,"\eta" above]
\end{tikzcd}
que cumplan:
\begin{itemize}
  \item La propiedad asociativa:
  \[ \begin{tikzcd}
  {(M \otimes M) \otimes M} \arrow[rr,"\alpha"] \arrow[d,"\mu\otimes\id"] & & {M \otimes (M \otimes M)} \arrow[d,"\id\otimes\mu"]\\
  {M \otimes M} \arrow[dr,"\mu"] & & {M \otimes M} \arrow[dl,"\mu"]\\
  & M
  \end{tikzcd}\]
  \item La propiedad de la unidad:
  \[ \begin{tikzcd}
  {I \otimes M} \arrow[r,"\eta\otimes\id"] \arrow[dr,"\rho" below] & {M \otimes M} \arrow[d,"\mu"] & {M \otimes I} \arrow[l,"\id\otimes\eta" above] \arrow[dl,"\rho"]\\
  & M
  \end{tikzcd}\]
\end{itemize}
\end{definition}

\begin{example}
Algunos ejemplos de monoides son:
\begin{itemize}
  \item Un monoide sobre la categoría monoidal $(\Set, \times, \{1\})$ es un monoide en el sentido algebraico.
  \item Un monoide sobre la categoría monoidal de grupos abelianos $(\Ab, \otimes, \Z)$ descrita en el ejemplo \ref{ej-abeliano} es un \newterm{anillo}.
  \item Un monoide sobre la categoría monoidal de $k$-espacios vectoriales $(\Vect_k, \otimes_k, k)$ es una \newterm{k-álgebra}.
\end{itemize}
\end{example}

Un ejemplo más será de gran importancia para nosotros, las mónadas.

\section{Referencias}
\begin{itemize}
  \item Awodey, S. (2006). \emph{Category Theory}, Capítulo 4.
  \item Mac Lane, S. (1997). \emph{Categories for the Working Mathematician}, Capítulo 7.
  \item Riehl, E. (2014). \emph{Category Theory in Context}, Capítulo 1.
  \item Riehl, E. (2014). \emph{Categorical homotopy theory}, Capítulo 3.
\end{itemize}

\chapter{Mónadas}
\section{Mónadas de una categoría}
Dada una categoría $\cat$, consideramos la categoría $\cat^\cat$, donde los objetos son endofunctores y los morfismos vienen dados por la composición entre functores.

\begin{proposition}
$\cat^\cat$ forma una categoría monoidal con la composición como producto tensorial y functor unidad $\Id$ como objeto unidad.
\end{proposition}
\begin{proof}
Esto es consecuencia de que $\Cat$ sea una $2$-categoría, como vimos en \ref{cat-2-categoria}.
\end{proof}

Por lo tanto, podemos definir monoides sobre $\cat^\cat$.
Dichos monoides se denominan \newterm{mónadas}.
Tratemos de dar una definición más explícita, especializando la definición de monoide teniendo en cuenta que:
\begin{itemize}
  \item $\circ$ es asociativa.
  \item El functor identidad $\Id \colon \cat \to \cat$ cumple que:
\[ \Id \circ F = F \]
\[ F \circ \Id = F\]
  \item El bifunctor $\circ$ actuando sobre transformaciones naturales es la composición horizontal $*$.
  \item Para la transformación natural identidad $\iota \colon F \Rightarrow F$:
\[ \mu * \iota = \mu F \]
\[ \iota * \mu = F \mu \]
  \item Escribiremos $F^n$ para referirnos a $\underbrace{F \circ \dots \circ F}_{n \text{ veces}}$.
\end{itemize}

\begin{definition}
Una \emph{mónada} es un endofunctor $F$ de una categoría $\cat$ con dos transformaciones naturales:
\begin{tikzcd}
F^2 \arrow[r,"\mu"] & F & \Id \arrow[l,"\eta" above]
\end{tikzcd}
que cumplan:
\begin{itemize}
  \item La propiedad asociativa:
  \[ \begin{tikzcd}
  &  {F^3} \arrow[dl,"\mu F" above,Rightarrow] \arrow[dr,"F\mu",Rightarrow]\\
  {F^2} \arrow[dr,"\mu",Rightarrow] & & {F^2} \arrow[dl,"\mu" above,Rightarrow]\\
  & F
  \end{tikzcd}\]
  \item La propiedad de la unidad:
  \[ \begin{tikzcd}
  F \arrow[r,"\eta F",Rightarrow] \arrow[dr,"\iota" below,Rightarrow] & {F^2} \arrow[d,"\mu",Rightarrow] & {F} \arrow[l,"F\eta" above,Rightarrow] \arrow[dl,"\iota",Rightarrow]\\
  & F
  \end{tikzcd}\]
\end{itemize}
\end{definition}


%Categories and Haskell 7
\begin{example}
Sea $\mathcal{P} \colon \Set \to \Set$ el endofunctor potencia y consideramos las transformaciones naturales.
\begin{align*} \mu_A \colon \mathcal{P}^2(A) & \to \mathcal{P}(A)\\
\{S_i\}_{i \in I} & \mapsto \bigcup_{i \in I} B_i
\end{align*}
\begin{align*} \eta_A \colon \Id A = A & \to \mathcal{P}(A)\\
a & \mapsto \{a\}
\end{align*}

Veamos que cumple las condiciones de mónada. 
Sea $A$ un conjunto cualquiera.
Obsérvese que $\mu_{\mathcal{P}(A)}(\mathcal{P}(A)) = A$, pues $A \in \mathcal{P}(A)$ y todo elemento de $\mathcal{P}(A)$ está contenido en $A$.
\begin{align*}
(\mu \circ \mu \mathcal{P})(\mathcal{P}^3(A)) & = \mu_{\mathcal{P}^2(A)}\left(\mu_{\mathcal{P}^3(A)}\mathcal{P}^3(A)\right)\\
& = \mu_{\mathcal{P}^2(A)}\mathcal{P}^2(A)\\
& = \mathcal{P}(A)
\end{align*}
\begin{align*}
(\mu \circ \mathcal{P}\mu)(\mathcal{P}^3(A)) & = \mu_{\mathcal{P}^2(A)}\left((\mathcal{P}\mu_{\mathcal{P}^2(A)})\mathcal{P}^3(A)\right)\\
& = \mu_{\mathcal{P}^2(A)}\mathcal{P}^2(A)\\
& = \mathcal{P}(A)
\end{align*}
\begin{align*}
(\mu \circ \eta\mathcal{P})(\mathcal{P}(A)) & = \mu_{\mathcal{P}^2(A)}\eta_{\mathcal{P}(A)}\mathcal{P}(A)\\
& = \mu_{\mathcal{P}^2(A)}(\{\mathcal{P}(A)\})\\
& = \mathcal{P}(A)
\end{align*}
\begin{align*}
(\mu \circ \mathcal{P}\eta)(\mathcal{P}(A)) & = \mu_{\mathcal{P}^2(A)} \left(\mathcal{P}\eta_{mathcal{P}(A)}(\mathcal{P}(A))\right)\\
& = \mu_{\mathcal{P}^2(A)} \left(\{\mathcal{P}(A)\}\right)\\
& = \mathcal{P}(A)
\end{align*}
\end{example}

%Categories and Haskell + Awodey 10
\section{Categoría de Kleisli}
La siguiente construcción nos llevará de vuelta al dominio de Haskell.
\begin{definition}
Sea $(F,\eta,\mu)$ una mónada sobre una categoría $\cat$.
La \index{categoría!de Kleisli}\emph{categoría de Kleisli} $\cat_F$ es la categoría donde:
\begin{itemize}
  \item Sus objetos son los objetos de $\cat$.
  \item Un morfismo $A \to_F B$ en $\cat_F$ es un morfismo de la forma $A \to F B$ en $\cat$.
  \item La composición entre dos morfismos $f \colon A \to_F B$ y $g \colon B \to_F C$ viene dado por la conmutatividad del siguiente diagrama:
  \[ \begin{tikzcd}
  A \arrow[r,"g \circ_F f"] \arrow[d,"f" left] & {F C}\\
  {F B} \arrow[r,"F g" below] & F^2 C \arrow[u,"\mu_C" right]
  \end{tikzcd}\]
  \item El morfismo identidad $\id_A$ en $\cat_F$ se correspoonde con $\eta_A$ en $\cat$.
\end{itemize}
\end{definition}
Para demostrar que la categoría de Kleisli es realmente un categoría, nos limitamos a comprobar la asociatividad:

Para $h \colon C \to F D$, $g \colon B \to F C$ y $f \colon A \to F B$, se tiene:
\begin{align*}
(h \circ_F g) \circ f = (\mu_D \circ F h \circ g) \circ_F f\\
& = \mu_D \circ F(\mu_D \circ F h \circ g)\circ g\\
& = \mu_D \circ F\mu_D \circ F^2 h \circ F g \circ g
\end{align*}
Por la naturalidad de $\mu$.

\section{Mónadas en Haskell}
¿Cómo vuelve todo esto a la programación funcional?
Consideremos el siguiente ejemplo:
\begin{minted}{haskell}
convertir :: String -> Maybe Float
inversa :: Float -> Maybe Float
\end{minted}
% =
% \end{minted}
donde \code{convertir} intenta convertir una cadena de texto a un número e inversa intenta dar la inversa de un número.
En estos dos ejemplos, hay casos donde la función fallaría.
Cuando \code{String} no se puede convertir a un número, o cuando \code{inversa} intenta invertir el número \code{0}.
Imaginemos que quisieramos combinar estas dos funciones en una nueva función:
\begin{minted}{haskell}
convertir_inversa :: String -> Maybe Float
\end{minted}
% =
% \end{minted}
Donde \code{convertir\_inversa} primero usa \code{convertir} y luego usa \code{inversa} sobre el posible resultado.
¿Cómo podríamos implementar esta función?
Un camino sería el siguiente:
\begin{minted}{haskell}
convertir_inversa str =
  let conv = convertir str in
  if isNothing conv
  then Nothing
  else inversa (fromJust conv)
\end{minted}

Recuérdese que \code{Maybe} es un functor, luego podemos aplicar \code{Maybe} a la aplicación inversa para obtener:
\begin{minted}{haskell}
fmap inversa :: Maybe Float -> Maybe (Maybe Float)
\end{minted}
ahora que el dominio de \code{fmap inversa} coincide con el codominio de \code{convertir}, podemos hacer su composición:
\begin{minted}{haskell}
fmap inversa . convertir :: String -> Maybe (Maybe Float) 
\end{minted}
Aquí entra en juego la transformación natural $\mu \colon F^2 \Rightarrow F$, que en Haskell recibe el nombre de \code{join}, de tipo 
\begin{minted}{haskell}
join :: Monad m => m (m a) -> m a
\end{minted}
% =
% \end{minted}
\code{join} nos permite transformar \code{Maybe (Maybe Float)} en \code{Maybe Float}.
Luego podríamos implementar \code{convertir\_inversa} como la composición de estas tres funciones:
\begin{minted}{haskell}
convertir_inversa = join . fmap inversa . convertir
\end{minted}
Estamos definiendo \code{convertir\_inversa} de manera que el siguiente diagram conmute:
\begin{displaymath}\begin{tikzcd}[column sep=6em,row sep=4em]
{String} \arrow[r,"convertir\_inversa",dashed] \arrow[d,"inversa"]& {Maybe\ Float}\\
{Maybe\ String} \arrow[r,"{fmap\ inversa}"] & {Maybe\ (Maybe\ Float)} \arrow[u,"join"]
\end{tikzcd}\end{displaymath}
Se puede reconocer aquí el diagrama que define la composición de Kleisli $\circ_F$.
En Haskell, dicha composición se denota a menudo como \code{>=>}, llamado conmúnmente \newterm{operador pez}, con tipo:

\begin{minted}{haskell}
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
\end{minted}
% =
% \end{minted}

y nos permite dar la siguiente definición sucinta de \code{convertir\_inversa}
\begin{minted}{haskell}
convertir_inversa = convertir >=> inversa
\end{minted}

Las mónadas en Haskell están definidas como una subclase de \code{Applicative}, que a su vez es una subclase de \code{Functor}.
Aunque no entraremos mucho en ello, \code{Applicative} representa los functores que mantienen la estructura monoidal de $\Hask$, y están definidos como:
\begin{minted}{haskell}
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{minted}
% =
% \end{minted}

Las mónadas se definen por la clase \code{Monad}:
\begin{minted}{haskell}
class Applicative m => Monad m where
  (>>=)       :: m a -> (a -> m b) -> m b
  return      :: a -> m a
\end{minted}
% =
% \end{minted}
Además, se deben cumplir las llamadas leyes de mónadas:
\begin{minted}{haskell}
return v >>= k = k v
x >>= return = x
m >>= (\y -> k y >>= h) = (m >>= k) >>= h
\end{minted}

El operador \code{(>>=)} se puede definir en terminos de \code{join :: m (m a) -> m a}, que era la implementación de la transformación natural $\mu$, y viceversa.
\begin{minted}{haskell}
x >>= f = join (fmap f x)
join x = x >>= id
\end{minted}
También se puede implementar el operador pez de la categoría de Kleisli \code{(>=>)} con \code{(>>=)}.
\begin{minted}{haskell}
f >=> g = \x -> f x >>= g
\end{minted}

Haskell añade una forma de hacer operaciones con mónadas de forma aparentemente imperativa:
\begin{minted}{haskell}
convertir_inversa x = do
  y <- convierte x
  inversa y
\end{minted}
Esta expresión es equivalente a:
\begin{minted}{haskell}
convertir_inversa x =
  convierte x >>= \y ->
    inversa y
\end{minted}

Hemos usado implícitamente que \code{Maybe} forma una mónada, comprobémoslo:
\begin{example}
El functor \code{Maybe} forma una mónada:
\begin{minted}{haskell}
instance Monad Maybe where
  (Just x) >>= f = f x
  Nothing >>= _ = Nothing

  return x = Just x
\end{minted}
Veamos que cumple las leyes de las mónadas:
\begin{minted}{haskell}
  return v >>= k 
= { definición de return }
  Just x >>= k
= { definición de (>>=) }
  k x
\end{minted}
Esto demuestra la primera ley.
Demostraremos las otras dos leyes por casos:
\begin{minted}{haskell}
  Nothing >>= return
= { definición de (>>=) }
  Nothing
\end{minted}
\begin{minted}{haskell}
  (Just x) >>= return
= { definición de (>>=) }
  return x
= { definición de return }
  Just x
\end{minted}
Esto demuestra la segunda ley.
Finalmente:
\begin{minted}{haskell}
  Nothing >>= (\y -> k y >>= h)
= { definición de (>>=) }
  Nothing
= { definición de (>>=) }
  Nothing >>= h
= { definción de (>>=) }
  (Nothing >>= k) >>= h
\end{minted}
\begin{minted}{haskell}
  (Just x) >>= (\y -> k y >>= h)
= { definición de (>>=) }
  (\y -> k y >>= h) x
= { reducción beta }
  k x >>= h
= { definición de (>>=) }
  (Just x >>= k) >>= h
\end{minted}
Por lo que \code{Maybe} forma una mónada.
\end{example}

\section{Referencias}
\begin{itemize}
  \item Awodey, S. (2006). \emph{Category Theory}, Capítulos 7 y 10.
  \item Buurlage, J. (2017). \emph{Categories and Haskell}, Capítulo 7.
  \item Milewski, B. (2014). \emph{Category Theory for Programmers}, Capítulo 20.
\end{itemize}

\chapter{F-álgebras}
\section{Functores polinomiales}
Nuestro objetivo va a ser describir una cierta clase de endofunctores que pueden ser descritos por producto y coproductos.
Por esto, supongamos que estamos en una categoría $\cat$ con productos y coproductos finitos.
Recordemos que esto implica, en particular que existen objetos iniciales y finales.
Llamemos al objeto inicial $0$ y al objeto final $1$.

\begin{definition}
Un \index{functor!polinomial}\emph{functor polinomial} es un miembro de la menor colección de functores que:
\begin{itemize}
  \item Contiene el functor identidad $\Id$.
  \item Contiene todo functor constante $\Delta_A$, que asocia todo elemento al objeto $A$.
  \item Es cerrada bajo composición, producto y coproducto, donde el producto de dos functores se corresponde con el functor:
  \[ (F \times G)(X) = F(X) \times G(X)\]
  y el coproducto se corresponde con:
  \[ (F + G)(X) = F(X) + G(X) \]
\end{itemize}
\end{definition}
Estos tipos de functores se expresan como un polinomio.
Por ejemplo, $F(X) = 1 + A \times X$ se debe entender como el functor que asocia a todo objeto $X$ el coproducto del producto de $A$ y $X$ con el objeto terminal $1$.

Consideremos el functor $F(X) = 1 + X$ y una $F$-álgebra $(A,f)$ donde $f \colon F(A) \to A$.
Por la definición de coproducto, este morfismo $f$ puede ser identificado con alguno de dos morfismos $f_1 \colon 1 \to U$ y $f_2 \colon A \to A$.
Viendo $F(X)$ como un tipo parametrizado por $X$, tiene sentido considerar $f_1$ y $f_2$ los \index{constructor}\emph{constructores} de $F(X)$.

Recordemos que en Haskell, el producto de dos tipos es su combinación en un par.
El objeto terminal se corresponde con \code{()} y el objeto inicial se define como
\begin{minted}{haskell}
data Empty
\end{minted}
Es decir, un tipo sin constructor.
En este contexto, podemos identificar $F(X)$ con el functor \code{Maybe a} y los morfismos $f_1$ y $f_2$ con \code{Nothing} y \code{Just}.

\section{F-álgebras}
\begin{definition}
Sea $\cat$ una categoría y $F \colon \cat \to \cat$ un endofunctor.
Una $F$-álgebra es un par $(A,\alpha)$, donde $A \in \cat$ y $\alpha \colon F a \to a$ es un morfismo de $\cat$.
\end{definition}

% A taste of category theory for computer scientist
En algunos libros, también se le llama \newterm{punto prefijo}.
Aunque no usaremos el nombre de punto prefijo, sí diremos que si $\alpha$ es isomorfismo, al par $(A,\alpha)$ par se le llama también \newterm{punto fijo}, señalando su similitud con la idea de punto fijo habitual de análisis.

Puede ser interesante darle una estructura de categoría a la colección de $F$-álgebras.
Para ello, necesitamos definir morfismos de un $(A,\alpha)$ a $(B,\beta)$.
Suponiendo que tenemos un morfismo $f \colon A \to B$, observamos que $F f \colon F A \to F B$, que puede ser compuesta con $\beta$:
\[ \beta \circ F f \colon F A \to B \]
Por otro lado:
\[ f \circ \alpha \colon F A \to B \]
La igualdad de estos dos morfismos nos dará la fundación de la categoría de $F$-álgebras.
Es más, como estos morfismos preservan bien la estructura de $F$-álgebran, les daremos el nombre (honorífico) de $F$-homomorfismo:

\begin{proposition}\label{prop:fmorfismo}
Sea $\cat$ una categoría y $F$ un endomorfismo en $\cat$.
Sea $Alg_F$ la colección de $F$-álgebras con homomorfismos $f \colon (A,\alpha) \to (B,\beta)$ tal que:
\begin{itemize}
\item $f \colon A \to B$ es un morfismo de $\cat$.
\item El siguiente diagrama conmuta
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F f"] & A \arrow[d,"f"]\\
F B \arrow[r,"\beta"] & B
\end{tikzcd}
\]
\end{itemize}
Entonces $Alg_F$ forma una categoría.
\end{proposition}
\begin{proof}
Basta ver que la composición está bien definida, pues las demás condiciones se cumplen trivialmente.
Sean $f \colon (A,\alpha) \to (B,\beta)$ y $g \colon (B,\beta) \to (C,\gamma)$ homomorfismos de $F$-álgebras.
Entonces cada cuadrado del siguiente diagrama conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F f"] & A \arrow[d,"f"]\\
F B \arrow[r,"\beta"] \arrow[d,"F g"] & B \arrow[d,"g"]\\
F C \arrow[r,"\gamma"] & C
\end{tikzcd}
\]
Tenemos que:
\[ g \circ f \circ \alpha = g \circ \beta \circ F f = \gamma \circ F g \circ F f \]
Como $F g \circ F f = F (g \circ f)$, tenemos que el siguiente diagrama conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F (g \circ f)"] & A \arrow[d,"g \circ f"]\\
F C \arrow[r,"\gamma"] & C
\end{tikzcd}
\]
Luego $g \circ f$ es un homomorfismo de $F$-álgebras.
\end{proof}

Una vez hemos determinado una nueva categoría, podemos empezar a buscar qué aspecto tienen nuestra construcciones universales en esta nueva categoría.
Resultará de particular interés el objeto inicial de una $Alg_F$ por el siguiente lema debido a Lambek~\cite{lambek}:

\begin{lemma}\label{lambek-lemma}
Sea $F \colon \cat \to \cat$ un endofunctor.
Si $(A,\alpha)$ es una $F$-álgebra inicial de $Alg_F$, entonces $(A,\alpha)$ es un punto fijo de $F$.
\end{lemma}
\begin{proof}
Sea $(A,\alpha)$ un objeto inicial en $Alg_F$.
Para decir que $(A,\alpha)$ es un punto fijo, debemos ver que $\alpha$ es un isomorfismo.
Para ello consideramos el $F$-álgebra $(F A, F \alpha)$.
Como $(A,\alpha)$ es inicial, existe un único homomorfismo $u \colon (A, \alpha) \to (F A, F \alpha)$.

Por un lado, $\alpha \circ u \colon (A, \alpha) \to (A, \alpha)$, pero el único homomorfismo de un objeto inicial a sí mismo es el morfismo identidad, luego $\alpha \circ u = \id_{(A, \alpha)}$.
Por definición de homomorfismo, el siguiente diagram conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F u"] & A \arrow[d,"u"]\\
F (F A) \arrow[r,"F \alpha"] & F A
\end{tikzcd}
\]
Entonces:
\[ u \circ \alpha = F \alpha \circ F u = F (\alpha \circ u) = F (\id_{(A, \alpha)}) = \id_{(F A, F \alpha)} \]
Luego $\alpha$ tiene inversa y debe ser isomorfismo.
\end{proof}

Dado un $F$-álgebra inicial $(A,\alpha)$, para todo otro $F$-áĺgebra $(B,\beta)$, al homomorfismo único de $(A,\alpha)$ a $(B,\beta)$ le daremos el imponente nombre de \newterm{catamorfismo}.
Por ejemplo, el homomorfismo $u$ de la demostración era un catamorfismo a $(F A, F \alpha)$.

\section{Catamorfismos en Haskell}

Debemos empezar implementando álgebras en Haskell:
\begin{minted}{haskell}
type Algebra f a = f a -> a
\end{minted}
Hay que tener en cuenta que no estamos imponiendo que \code{f} sea un functor, ya que Haskell no permite imponer restricciones a constructores de datos sin recurrir a GADTs\footnote{\url{https://wiki.haskell.org/Data_declaration_with_constraint}}.

Lo siguiente que necesitamos es implementar el punto fijo de \code{f}:
\begin{minted}{haskell}
newtype Fix f = U (f (Fix f))
\end{minted}
Como \code{Fix} tiene un único constructor, hay un isomorfismo entre \code{Fix f} y \code{f (Fix f)}.
Este isomorfismo es \code{U}, y su inversa es:
\begin{minted}{haskell}
unFix :: Fix f -> f (Fix f)
unFix (U f) = f
\end{minted}

Ahora que sabemos que (\code{Fix f}, \code{U}) es el álgebra inicial, sabemos que existe un catamorfismo de este álgebra a todas las demás álgebras.
Consideramos cualquier otra álgebra (\code{b}, \code{g}), con \code{g :: Algebra f b}. Sea \code{m :: Fix f -> b} el correspondiente catamorfismo, entonces por \ref{prop:fmorfismo}:

\[
\begin{tikzcd}
{f (Fix f)} \arrow[r,"fmap\ m"] \arrow[d,"U"] & f b \arrow[d,"g"]\\
{Fix f} \arrow[r,"m"] & b
\end{tikzcd}
\]

Podemos invertir \code{U} con \code{unFix}, luego la conmutatividad del diagrama es equivalente a que:
\begin{minted}{haskell}
m = g . fmap m . unFix
\end{minted}
Usamos esto para definir recursivamente el catamorfismo:
\begin{minted}{haskell}
cata :: (Functor f) => (Algebra f b) -> (Fix f -> b)
cata g = g . fmap (cata g) . unFix
\end{minted}

Veamos un ejemplo con el functor \code{Maybe}
\begin{example}
Especialicemos el código anterior para \code{Maybe}:
\begin{minted}{haskell}
type AlgebraM a = Algebra Maybe a
type FixM = Fix Maybe
\end{minted}
Por ahora, no dice mucho. Pero al añadir las siguientes de líneas obtenemos una perspectiva interesante:
\begin{minted}{haskell}
type Nat = FixM

cero :: Nat
cero = U Nothing
suc :: Nat -> Nat
suc = U . Just
\end{minted}
Es decir, los naturales pueden verse como el punto fijo del functor \code{Maybe}.
\end{example}

\section{F-coálgebras en Haskell}
Una \index{F-coálgebra}\emph{$F$-coálgebra} es, naturalmente, el dual de una $F$-álgebra.
Más precisamente, es un par $(A,\alpha)$, donde $\alpha \colon A \to F A$.
En Haskell:
\begin{minted}{haskell}
type Coalgebra f a = a -> f a
\end{minted}

Al igual que con las álgebras, las $F$-coálgebras forman una categoría $Coalg_F$.
El lema de Lambek \eqref{lambek-lemma} en el contexto de las coálgebras dice así:
\begin{lemma}\ref{lambek-lemma}
Sea $F \colon \cat \to \cat$ un endofunctor.
Si $(A,\alpha)$ es una $F$-coálgebra terminal de $Coalg_F$, entonces $(A,\alpha)$ es un punto fijo de $F$.
\end{lemma}

El único homomorfismo de un $F$-coálgebra a la $F$-coálgebra terminal se denomina \newterm{anamorfismo}.
Como en el caso del catamorfismo, podemos definirlo recursivamente:
\begin{minted}{haskell}
ana :: (Functor f) => (Coalgebra f b) -> (b -> Fix f)
ana g = U . fmap (ana g) . g
\end{minted}

\begin{example}
Consideramos el functor $F(X)=1+A\times X$, que se puede ver como la composición de $G(X) = A \times X$ con $H(X) = 1+X$.
En términos de Haskell, la composición de \code{(a,)} con \code{Maybe}.
\begin{minted}{haskell}
data F a x = Maybe (a,x)
\end{minted}
Su punto fijo es un tipo de la forma $X = 1 + A \times X$, que se corresponde con el functor lista \code{[a]}.

Por lo tanto, en este contexto \code{ana} tiene la forma:
\begin{minted}{haskell}
ana :: (x -> Maybe (a,x)) -> (x -> [a])
\end{minted}
\code{ana} nos permite construir una lista (posiblemente infinita) a partir de una \textquote{semilla} \code{x} y una función que devuelva \code{a}, el valor generado, y \code{x}, una nueva semilla. 
Una implementación de este anamorfismo del paquete básico de Haskell es la función \code{unfoldr}.
\end{example}

\section{Referencias}
\begin{itemize}
  \item Pierce, B.C. (1991). \emph{A taste of category theory for computer scientist}, Capítulo 3.4.
  \item Milewski, B. (2014). \emph{Category Theory for Programmers}, Capítulo 24.
\end{itemize}

\chapter*{Epílogo}

A estas alturas hemos visto las piezas básicas con las que se construye la teoría de categorías y cómo aparecen en programación funcional.
Sin embargo, la teoría de categoría es un campo mucho más grande que lo podemos abarcar en este trabajo.
Aquí damos un punto de comienzo para seguir el estudio de teoría de categorías.

En el capítulo 4, hemos identificado qué propiedades debe cumplir una categoría para que sea equivalente a la lógica proposicional intuicionista.
Añadiendo más propiedades a las categorías podemos obtener distintas lógicas.
Por ejemplo, podemos ``mejorar'' esta lógica a lógica intuicionista de orden superior.
Para ello, necesitaremos definir los \index{clasificador de subobjetos}\emph{clasificador de subobjetos}.
En pocas palabras, un subobjeto es cualquier objeto $S$ con un monomorfismo $S \to X$.
Un clasificador de subobjetos de $X$ es una colección de morfismos que caracterizan cada uno de sus subobjetos.
En pocas palabras, es una generalización de la idea de función característica de los conjuntos:
\begin{align*}
\chi_S & \colon X \to \{0,1\}\\
\chi_S (x) & = \begin{cases}0 & \text{si }x \notin S\\1 & \text{si }x \in S\end{cases}
\end{align*}
Una categoría cerrada cartesianamente con un clasificador de subobjetos se denomina \newterm{topos elemental}.
Resulta que un \newterm{topos elemental} es equivalente a la lógica intuicionista de orden superior.

En los capítulos 5, hemos introducido el concepto de monoide, pero también el concepto de categoría enriquecida y $2$-categoría.
Siguiendo esta idea llegamos a la teoría de categorías de orden superior.
Lurie dedica su libro a su estudio.


\backmatter

\bibliographystyle{acm}
\bibliography{bibliografia}

\printindex

\end{document}
%!TEX TS-program = pdflatex
%!TEX encoding = utf8
\documentclass[12pt, twoside]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, spanish, es-noshorthands]{babel}

\usepackage{hyperref}
\usepackage{url}

\usepackage{tikz}
\usetikzlibrary{babel}
\usetikzlibrary{cd}

%% FONTS: libertine+biolinum+stix
\usepackage{mathpazo}

% =====================
% = Datos importantes =
% =====================
% hay que rellenar estos datos y luego
% ir a \begin{document}

\title{Teoría de Categorías y Programación Funcional}
\author{Diego Pedraza López}
\date{\today}
\newcommand{\tutores}[1]{\newcommand{\guardatutores}{#1}}
\tutores{Prof. Tutor José A. Alonso Jiménez}

% ======================
% = Páginas de títulos =
% ======================
\makeatletter
\edef\maintitle{\@title}
\renewcommand\maketitle{%
  \begin{titlepage}
      \vspace*{1.5cm}
      \parskip=0pt
      \Huge\bfseries
      \begin{center}
          %\leavevmode\includegraphics[totalheight=6cm]{sello.pdf}\\[2cm]
          \@title
      \end{center}
      \vspace{1cm}
      \begin{center}
          \@author
      \end{center}
  \end{titlepage}

  \begin{titlepage}
  \parindent=0pt
  \begin{flushleft}
  \vspace*{1.5mm}
  \setlength\baselineskip{0pt}
  \setlength\parskip{0mm}
  \begin{center}
      %\leavevmode\includegraphics[totalheight=4.5cm]{sello.pdf}
  \end{center}
  \end{flushleft}
  \vspace{1cm}
  \bgroup
  \Large \bfseries
  \begin{center}
  \@title
  \end{center}
  \egroup
  \vspace*{.5cm}
  \begin{center}
  \@author
  \end{center}
  \vspace*{1.8cm}
  \begin{flushright}
  \begin{minipage}{8.45cm}
      Memoria presentada como parte de los requisitos para la obtención del título de
      Grado en Matemáticas por la Universidad de Sevilla.

      \vspace*{7.5mm}

      Tutorizada por
      % \vspace*{5mm}
  \end{minipage}\par
  \begin{tabularx}{8.45cm}[b]{@{}l}
      \guardatutores
  \end{tabularx}
   \end{flushright}
      \vspace*{\fill}
   \end{titlepage}
   %%% Esto es necesario...
   \pagestyle{tfg}
   \renewcommand{\chaptermark}[1]{\markright{\thechapter.\space ##1}}
   \renewcommand{\sectionmark}[1]{}
   \renewcommand{\subsectionmark}[1]{}
  }
\makeatother

\usepackage{minted}
\newcommand{\newterm}[1]{\index{#1}\emph{#1}}
\newcommand{\code}[1]{\Verb+{#1}+}

% ======================================
% = Color de la Universidad de Sevilla =
% ======================================
\definecolor{USred}{cmyk}{0,1.00,0.65,0.34}

% =========
% = Otros =
% =========
\usepackage[]{tabularx}
\usepackage[]{enumitem}
\setlist{noitemsep}

% ==========================
% = Matemáticas y teoremas =
% ==========================
\usepackage[]{amsmath}
\usepackage[]{amsthm}
\usepackage[]{mathtools}
\usepackage[]{bm}
\usepackage[]{thmtools}
\usepackage[]{amsfonts}
\newcommand{\marcador}{\vrule height 10pt depth 2pt width 2pt \hskip .5em\relax}
\newcommand{\cabeceraespecial}{%
    \color{USred}%
    \normalfont\bfseries}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\cabeceraespecial\marcador,
    notefont=\cabeceraespecial,
    notebraces={(}{)},
    bodyfont=\normalfont\itshape,
    postheadspace=1em,
    numberwithin=chapter,
    headindent=0pt,
    headpunct={.}
    ]{importante}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\normalfont\itshape\color{USred},
    notefont=\normalfont,
    notebraces={(}{)},
    bodyfont=\normalfont,
    postheadspace=1em,
    numberwithin=chapter,
    headindent=0pt,
    headpunct={.}
    ]{normal}
\declaretheoremstyle[
    spaceabove=\medskipamount,
    spacebelow=\medskipamount,
    headfont=\normalfont\itshape\color{USred},
    notefont=\normalfont,
    notebraces={(}{)},
    bodyfont=\normalfont,
    postheadspace=1em,
    headindent=0pt,
    headpunct={.},
    numbered=no,
    qed=\color{USred}\marcador
    ]{demostracion}

% Los nombres de los enunciados. Añade los que necesites.
\declaretheorem[name=Observaci\'on, style=normal]{remark}
\declaretheorem[name=Corolario, style=normal]{corollary}
\declaretheorem[name=Proposici\'on, style=normal]{proposition}
\declaretheorem[name=Lema, style=normal]{lemma}
\declaretheorem[name=Ejemplo, style=normal]{example}

\declaretheorem[name=Teorema, style=importante]{theorem}
\declaretheorem[name=Definici\'on, style=importante]{definition}

\let\proof=\undefined
\declaretheorem[name=Demostraci\'on, style=demostracion]{proof}

\usepackage{scalerel}
\newcommand{\cat}{{\mathcal{C}}}
\newcommand{\Set}{{Set}}
\newcommand{\Grp}{{Grp}}
\newcommand{\Ring}{{Ring}}
\newcommand{\Cat}{{Cat}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\Top}{{Top}}
\newcommand{\Hask}{{Hask}}
\newcommand{\sii}{{\ \Leftrightarrow\ }}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\Const}{Const}

% ============================
% = Composición de la página =
% ============================
\usepackage[
    a4paper,
    textwidth=80ex,
]{geometry}

\linespread{1.069}
\parskip=10pt plus 1pt minus .5pt
\frenchspacing
% \raggedright

\setlength{\headheight}{20pt}
% ==============================
% = Composición de los títulos =
% ==============================

\usepackage[explicit]{titlesec}

\titleformat{\chapter}[hang]
    {\Huge\sffamily\bfseries}
    {\thechapter\hspace{20pt}\textcolor{USred}{\vrule width 2pt}\hspace{20pt}}{0pt}
    {#1}
\titleformat{\section}
  {\normalfont\Large\sffamily\bfseries}{\thesection\space\space}
  {1ex}
  {#1}
\titleformat{\subsection}
  {\normalfont\large\sffamily}{\thesubsection\space\space}
  {1ex}
  {#1}

% =======================
% = Cabeceras de página =
% =======================
\usepackage[]{fancyhdr}
\usepackage[]{emptypage}
 \fancypagestyle{tfg}{%
     \fancyhf{}%
     \renewcommand{\headrulewidth}{0pt}
     \renewcommand{\footrulewidth}{0pt}
     \fancyhead[LE]{{\normalsize\color{USred}\bfseries\thepage}\quad
                     \small\textsc{\MakeLowercase{\maintitle}}}
     \fancyhead[RO]{\small\textsc{\MakeLowercase{\rightmark}}%
                     \quad{\normalsize\bfseries\color{USred}\thepage}}%
                     }
\usepackage{makeidx}
\makeindex
\usepackage{csquotes} % comillas españolas

% =============================
% = El documento empieza aquí =
% =============================
\begin{document}

\maketitle

\frontmatter
\tableofcontents

\mainmatter


\chapter*{English Abstract}
\addcontentsline{toc}{chapter}{English Abstract}
\markright{English Abstract}

\begin{otherlanguage}{english}
    Abstract goes here
\end{otherlanguage}

\chapter{Fundamentos}

\section{Categorías}

La teoría de categorías nos ofrece al mismo tiempo un lenguaje común por el que se pueden entender matemáticos y programadores y una poderosa abstracción a la composición de funciones.
La idea empieza por el concepto de categoría, que resulta sorprendentemente ubicuo en la matemática.
En principio, una categoría es sólo una colección de objetos y flechas entre dichos objetos donde se define una composición de flechas.
Aunque los axiomas que pediremos a las categorías no son muchos, resulta que podemos crear una gran cantidad de resultados interesantes y muy genéricos.

\begin{definition}
Una \newterm{categoría} $\cat$ es:
\begin{itemize}
\item Una colección de \index{objeto}\emph{objetos} $O(\cat)$.
\item A cada par de objetos $A$, $B$ en $O(\cat)$, una colección de \index{morfismo}\emph{morfismos} $C(A,B)$ de $A$ a $B$.
Un morfismo $f$ en $C(A,B)$ se denotará $f \colon A \to B$.
\item A cada par de morfismos $f \colon A \to B$, $g \colon B \to C$, un morfismo de $g \circ f \colon A \to C$ llamado \newterm{morfismo composición} de $f$ y $g$.
\end{itemize}
de manera que:
\begin{itemize}
\item Para cada objeto $A \in O(\cat)$, existe un morfismo $\id_A \in C(A,A)$ que llamamos \newterm{morfismo identidad}.
\item Para todo morfismo $f \colon A \to B$:
\[ \id_B \circ f = f \circ \id_A = f \]
\item Asociatividad de la composición: Para toda tripleta de morfismos $f \colon A \to B$, $g \colon B \to C$, $h \colon C \to D$:
\begin{equation}\label{cat:3} (h \circ g) \circ f = h \circ (g \circ f) \end{equation}
\end{itemize}
\end{definition}

La notación para referirse a objetos y morfismos de una categoría varía mucho dependiendo del autor.
Por ejemplo, Awodey usa $\cat_0$ y $\cat_1$ para referirse a los objetos y los morfismos de una categoría $\cat$ respectivamente~\cite{awodey}.
Esta notación funciona bien para la introducción de categorías de orden superior.

Otra notación habitual es usar $Hom(A,B)$ para referirse a la colección de morfismos entre $A$ y $B$, lo que hemos llamado $C(A,B)$.

A menudo usaremos diagramas para expresar visualmente ciertas propiedades.
En Teoría de Categoría, existe una definición precisa de diagrama, pero por ahora, no tenemos las herramientas suficientes para explicarlo.
Basta imaginar que es un grafo formado por una cantidad finita de objetos y morfismos de una categoría.

El concepto de conmutatividad de un diagrama es el habitual de otros campos.
Como ejemplo, la propiedad \eqref{cat:3} se puede expresar diciendo que el diagrama
\[
\begin{tikzcd}
A \arrow[rr,"f"]\arrow[rrdd,"g \circ f" above=5pt] \arrow[dd,"h\circ g \circ f"] & & B \arrow[lldd,"h\circ g" below=5pt, crossing over] \arrow[dd,"h"]\\
&\\
C & & D \arrow[ll,"g"]
\end{tikzcd}
\]
conmuta.

Dado un morfismo $f \colon A \to B$, llamaremos dominio de $f$ a $\dom f = A$.
De igual manera, el codominio de $f$ será $\cod f = B$.

Además, llamaremos a la colección de morfismos de una categoría $M(\cat)$.

No hay ni mucho menos falta de ejemplos de categorías, ni siquiera si nos limitamos a un campo específicio de la matemática.
Algunos ejemplos ilustrativos son los siguientes:

\begin{example}
La categoría $\Set$ formada por los conjuntos como objetos y funciones entre conjuntos como morfismos.
La composición de morfismos se corresponde, como es de esperar, con la composición de funciones.
\end{example}

\begin{example}
La categoría $\Grp$ formada por los grupos como objetos y homomorfismos entre grupos como morfismos.
\end{example}

\begin{example}
La categoría $\Top$ formada por los espacios topológicos como objetos y funciones continuas como morfismos.
\end{example}

\begin{example}
Todo \newterm{conjunto parcialmente ordenado} (o \index{poset|see {conjunto parcialmente ordenado}}\emph{poset}) $(X,\leq)$ puede verse como una categoría, donde los objetos son los elementos de $X$ y hay un único morfismo $f \colon a \to b$ si y sólo si $a \leq b$.
Este es nuestro primer ejemplo donde los morfismos no son equivalentes a función.
La composición de dos morfismos aquí es equivalente a la propiedad transitiva de la relación de orden $\leq$.
Es más, el morfismo identidad es equivalente a la propiedad reflexiva.
\end{example}

También nos interesarán en algunos casos categorías que posean una estructura finita dada, como:
\begin{example}
La categoría $\mathbb{1}$ formada por un sólo objeto y su morfismo identidad:
\[ \begin{tikzcd}
A \arrow[loop above,"\id_A"]
\end{tikzcd}\]
\end{example}

\begin{example}
La categoría $\mathbb{2}$:
\[ \begin{tikzcd}
A \arrow[loop above,"\id_A"] \arrow[r,"f"] & B \arrow[loop above,"\id_B"]
\end{tikzcd}\]
\end{example}

Las categorías finitas serán de gran uso cuando hablemos más adelante de los diagramas.
Por otro lado, las categorías con las que trabajaremos a menudo serán enormes, donde a veces la teoría de conjuntos habitual se nos quedará pequeña.
Por ejemplo, en la teoría de conjuntos habitual, el conjunto de todos los conjuntos es una noción inconsistente como consecuencia del Teorema de Cantor.
Por esta razón, hablaremos a menudo de \textquote{colección} o \textquote{familia} y evitaremos la palabra \textquote{conjunto} en general.

En ocasiones, sí nos será útil que la colección de objetos o morfismos forme un conjunto.
Para ello, introducimos las siguientes definiciones:

\begin{definition}
Una categoría $\cat$ es \index{categoría!pequeña}\emph{pequeña} si $O(\cat)$ y $M(\cat)$ forman conjuntos.
\end{definition}

Por ejemplo, toda categoría finita es pequeña, pero $\Set$ no es pequeña.

\begin{definition}
Una categoría $\cat$ es \index{categoría!localmente pequeña}\emph{localmente pequeña} si para todo par de objetos $A$ y $B$ en $\cat$, $C(A,B)$ forma un conjunto.
\end{definition}

Todos los ejemplos que hemos dado son localmente pequeños.
Para poder dar ejemplos de categorías que no son localmente pequeñas, necesitaremos más conceptos.
Casi siempre trabajaremos con categorías localmente pequeñas.

También podemos construir categorías a partir de otras categorías.
El ejemplo más importante es el de la categoría opuesta:
\begin{definition}
Dada una categoría $\cat$, la \index{categoría!opuesta}\emph{categoría opuesta} o \index{categoría!dual}\emph{dual} $\cat^{op}$ es la categoría con los mismos objetos que $\cat$ y donde un morfismo $f \colon B \to A$ en $\cat^{op}$ es un morfismo $f \colon A \to B$ en $\cat$.
\end{definition}

Evidentemente se tiene que $\left(\cat^{op}\right)^{op} = \cat$.
A menudo nos encontraremos con conceptos que están relacionados por el dual de una categoría.
Por ejemplo, el objeto terminal de una categoría (que veremos más adelante) no es más que el objeto inicial de su categoría opuesta.

\begin{definition}
Sea $A$, $B$ objetos de una categoría $\cat$.
Un morfismo $f \colon B \to C$ de una categoría es un monomorfismo (o mónico) si para todo morfismo $g \colon A \to B$ y $h \colon A \to B$ tal que $f \circ g = f \circ h$, entonces $g = h$.
\end{definition}

\begin{proposition}
En \Set, un morfismo es mónico si y sólo si es inyectivo.
\end{proposition}

\begin{proof}
Sea $f \colon B \to C$ un monomorfismo. Sea $b, b' \in B$ tal que $f(b) = f(b')$. Sea $A = \{b\}$ y definimos $g \colon A \to B$ como $g(b)=b'$.
Entonces $f(\id_A(b)) = f(g(b))$
como $b$ es el único elemento de $A$, tenemos que:
\[ f \circ \id_A = f \circ g \]
luego, como $f$ es monomorfismo:
\[ \id_A = g \]
Entonces $b'=g(b)=\id_A(b)=b$.

Consideramos ahora $f \colon B \to C$ un morfismo inyectivo.
Sean los morfismos $g, h \colon A \to B$ tal que $f \circ g = f \circ h$.
Sea $a \in A$ cualquiera. Como $f(g(a)) = f(h(a))$ y $f$ es inyectiva, entonces $g(a) = h(a)$.
Entonces $g = h$. 
\end{proof}

\begin{definition}
Un morfismo $f \colon A \to B$ es epimorfismo (o épico) si para cualquier par de morfismos $g \colon B \to C$ y $h \colon B \to C$, se tiene que $g \circ f = h \circ f$ implica que $g = h$.
\end{definition}

\begin{proposition}
En \Set, un morfismo es épico si y sólo si es sobreyectivo.
\end{proposition}

\begin{proof}
Sea $f \colon A \to B$ un epimorfismo. Supongamos que $f$ no fuera sobreyectivo. Entonces existe $b \in B$ que no es preimagen de ningún elemento de $A$. Sean $g, h \colon B \to \{1,2\}$ tal que $g(x)=h(x)=1$ para todo $x \in B \setminus \{b\}$, $g(b) = 1$ y $h(b) = 2$. Entonces tenemos que $g \circ f = h \circ f$. Como $f$ es epimorfismo, esto implica que $g = h$, pero esto entra en una contradicción.

Sea $f \colon A \to B$ un morfismo sobreyectivo. Sean $g, h \colon B \to C$ tal que $g \circ f = h \circ f$. Para todo $b \in B$, existe $a \in A$ tal que $f(a)=b$, luego: $g(b) = g(f(a)) = h(f(a)) = h(b)$, luego $g = h$.
\end{proof}

\begin{definition}
Un morfismo $f \colon A \to B$ es \newterm{isomorfismo} si existe $g \colon B \to A$ tal que $g \circ f = \id_A$ y $f \circ g = \id_B$.

Dos objetos $A$ y $B$ se dirán \emph{isomorfos} si existe un isomorfismo entre ellos.
\end{definition}

Claramente, en $\Set$, un morfismo mónico y épico es isomórfico.
Sin embargo, todos los morfismos de un poset son épicos y mónicos, pero sólo los morfismos identidad son isomorfismos.

\section{Functores}
Parece que muchos conceptos como $\Set$ o $\Top$ forman categorías.
De aquí surge la siguiente cuestión: ¿Podríamos hacer una categoría de categorías?
Es decir, una categoría donde los objetos mismos sean categorías.
Para ello, debemos definir morfismos entre categorías que respetan su estructura interna.
Aunque la misma razón por la que no hay conjunto de conjuntos, no hay una categoría de categorías, esta cuestión motiva la definición de functor:

\begin{definition}\label{def:functor}
Un \newterm{functor} $F$ entre un par de categorias $\cat$ y $\mathcal{D}$ es un par de funciones:
\begin{itemize}
\item $F_O : O(\cat) \to O(\mathcal{D})$.
\item $F_M : M(\cat) \to M(\mathcal{D})$.
\end{itemize}
tal que:
\begin{itemize}
\item Respeta el dominio y codominio de los morfismos: A cada morfismo $f : A \to B$:
\[ F_M(f) : F_O(A) \to F_O(B) \]
\item Respeta el morfismo identidad:
\[ F_M(\id_A) = \id_{F_O(A)} \]
\item Respeta la composición de morfismo: Para todo morfismos $f : A \to B$, $g : B \to C$.
\[ F_M(g \circ f) = F_M(g) \circ F_M(f) \]
\end{itemize}
\end{definition}

Escribiremos $F \colon \cat \to \mathcal{D}$ y a menudo usaremos $F$ para referirnos a $F_M$ ó $F_O$ según el contexto.

Viendo los functores como funciones entre categorías, es natural que queramos definir composición entre functores.
\begin{definition}
Dado dos functores $F \colon \cat \to \mathcal{D}$ y $G \colon \mathcal{D} \to \mathcal{E}$, definimos $G \circ F$ como el functor con:
\begin{itemize}
  \item $(G \circ F)_O = G_O \circ F_O$.
  \item $(G \circ F)_M = G_M \circ F_M$.
\end{itemize}
\end{definition}
\subsection{Functores en Haskell}
Recordemos que en el contexto de la programación con tipos, Haskell sólo trabaja con tipos de la categoría \code{Hask}.
Los functores con los que podemos trabajar son de endofunctores de \code{Hask}, es decir, functores que van de \code{Hask} a \code{Hask} -- de tipos a tipos.

Haskell implementa los functores a través de sus \code{typeclasses}.
\begin{minted}{haskell}
class Functor f where
  fmap :: (a -> b) -> f a -> f b
\end{minted}

La \code{f} actúa como $F$ y como $F_O$ en \ref{def:functor}.
Si hay dudas de qué es lo que hace \code{fmap} aquí, resulta útil añadir unos paréntesis en el lugar adecuado:

\begin{minted}{haskell}
fmap :: (a -> b) -> (f a -> f b)
\end{minted}

\code{fmap} toma un función cualquiera \code{a -> b} y la transforma en una función del tipo \code{f a -> f b}.
Esto es precisamente lo que antes llamábamos $F_M$.
Con esto en mente, adaptemos las leyes de los functores en Haskell:
\begin{minted}{haskell}
fmap id = id
fmap (g . f) = fmap g . fmap f
\end{minted}
Recordemos que en Haskell, la composición de funciones $g \circ f$ se expresa usando \code{g . f}.
Antes de pasar a unos ejemplos, hay que tener en cuenta que Haskell no dispone de ningún mecanismo que comprueba que estas igualdades se cumplen.
Queda como responsabilidad del programador que la clase \code{Functor} no se aplique sobre tipos que no cumplen las leyes de functores. 

\begin{example}
Nuestro primer ejemplo es \code{Maybe}.
\begin{minted}{haskell}
data Maybe a = Nothing | Just a 
\end{minted}

Podemos leer esta definición como \code{Maybe a} contiene o bien un valor constante o bien un valor del tipo \code{a}.
Hay que tener cuidado con la diferencia entre \code{Maybe} y \code{Just}.
\code{Maybe} es lo que llamamos un constructor de tipo.
Veremos que este constructor de tipo, que asocia a cada tipo \code{a} el tipo \code{Maybe a}, es un functor.
Por otro lado, \code{Just} es una función polimórfica --y por lo tanto una familia de morfismos en \code{Hask}-- de \code{a} a \code{Maybe a}.

Para ver que \code{Maybe} es un functor, tenemos que describir como actua sobre morfismos, ahí es donde entra en juego la función \code{fmap}.

\begin{minted}{haskell}
instance Functor Maybe where
  fmap f Nothing = Nothing
  fmap f (Just x) = Just (f x) 
\end{minted}
\end{example}

\subsection{Functor contravariantes}
Consideramos ahora el concepto de functor contravariante a través de un cambio en la definición de functor:
\begin{definition}\label{def:cofunctor}
Un \index{functor!contravariante}\emph{functor contravariante} $F$ entre un par de categorias $\cat$ y $\mathcal{D}$ es un par de funciones:
\begin{itemize}
\item $F_O : O(\cat) \to O(\mathcal{D})$.
\item $F_M : M(\cat) \to M(\mathcal{D})$.
\end{itemize}
tal que:
\begin{itemize}
\item \textbf{Intercambia} el dominio y codominio de los morfismos: A cada morfismo $f : A \to B$:
\[ F_M(f) : F_O(B) \to F_O(A) \]
\item Respeta el morfismo identidad:
\[ F_M(\id_A) = \id_{F_O(A)} \]
\item \textbf{Intercambia} la composición de morfismo: Para todo morfismos $f : A \to B$, $g : B \to C$.
\[ F_M(g \circ f) = F_M(f) \circ F_M(g) \]
\end{itemize}
\end{definition}

Los functores con los que hemos trabajado hasta ahora serán llamados \index{functor!covariante}\emph{functores covariantes}, pero a menudo prescindiremos del adjetivo.
Una razón para esto es que no hay diferencia esencial entre functor contravariante y functor covariante cuando observamos que los \textquote{intercambios} en la definición son equivalentes a que el functor parta de $\cat^{op}$.
Por esta razón, hablaremos de functor contravariante cuando tratemos con un functor covariante de la forma:
\[ F \colon \cat^{op} \to D \]

\section{Construcciones universales}
Podemos caracterizar ciertos objetos en una categoría por alguna propiedad especial que cumplan. En lugar de pedir que sólo haya un objeto que cumpla dicha propiedad, nos limitamos a pedir que todos los objetos que cumplan la propiedad sean isomorfos. Estas propiedades son llamadas \emph{propiedades universales}.

\begin{definition}
Decimos que un objeto $A \in \cat$ es \newterm{inicial} si para cada objeto $B \in \cat$, hay exactamente un morfismo $f \colon A \to B$.

Análogamente, decimos que un objeto $B \in \cat$ es \newterm{terminal} si para cada objeto $A \in \cat$, hay exactamente un morfismo $f \colon A \to B$.
\end{definition}

Cuando hablemos de un objeto inicial, usaremos a menudo la notación $0$.
Análogamente, usaremos $1$ para referirnos a un objeto terminal.

\begin{example}
Veamos algunos ejemplos en categorías usuales:
\begin{itemize}
  \item En $\Set$, el conjunto vacío es un objeto inicial y cualquier conjunto unitario es terminal.
  \item En $\Grp$, el grupo trivial es inicial y terminal.
  \item En $\Ring$, el anillo unitario es terminal y el anillo $(\Z,+,\cdot)$ es inicial.
  \item En un poset, visto como categoría, el objeto inicial es el elemento mínimo global y el objeto terminal es el elemento máximo global, si existen.
\end{itemize}
\end{example}

De estos ejemplos vemos que:
\begin{itemize}
  \item Los objetos iniciales y terminales no son necesariamente únicos.
  \item Un objeto puede ser inicial y terminal.
  \item Una categoría puede no poseer objetos iniciales o terminales.
\end{itemize}

Aunque no haya unicidad de objetos iniciales o terminales, sí hay una relación entre todos los objetos iniciales o terminales.
\begin{proposition}
Sea $\cat$ una categoría. Sean $A$ y $B$ objetos iniciales (o terminales) de $\cat$.
Entonces existe un único isomorfismo $A \to B$.
\end{proposition}
\begin{proof}
Como $A$ es inicial, existe un único morfismo $f \colon A \to B$.
Como $B$ es inicial, existe un único morfismo $g \colon B \to A$.
Entonces $g \circ f \colon A \to A$.
Al ser $A$ inicial, sólo hay un morfismo $A \to A$, que debe ser el morfismo identidad, luego $g \circ f = \id_A$.
Análogamente, $f \circ g = \id_B$.

Luego $f$ es isomorfismo.
\end{proof}

\section{Diagramas y conos}
En estas páginas hemos trabajado a menudo con categorías con infinitos objetos e innumerables morfismos.
Sin embargo, resulta de interés estudiar una estructura particular de objetos y morfismos que podamos encontrar dentro de esa categoría.
Para ello, formalizaremos un concepto que hemos manejado antes, los diagramas.
\begin{definition}
Sean $\cat$ y $\mathcal{I}$ dos categorías. Un \newterm{diagrama} de $\cat$ con \emph{forma} $\mathcal{I}$ es un functor $D \colon \mathcal{I} \to \cat$.
\end{definition}
Es decir, técnicamente diagrama será sólo otra palabra para functor.
En la práctica, usaremos diagrama cuando querramos distinguir una estructura particular dentro de una categoría.
También se llamará a $\mathcal{I}$ \index{categoría!índice}\emph{categoría índice} del diagrama.

\begin{example}\label{ejemplo-span}
Sea $\mathcal{I}$ la siguiente categoría índice:
\[ \begin{tikzcd}
A & B \arrow[l] \arrow[r] & C
\end{tikzcd} \]
Entonces el diagrama $D \colon \mathcal{I} \to \cat$ es llamado \newterm{span}.
\end{example}

\begin{definition}
Sea $\cat$ una categoría y $D \colon \mathcal{I} \to \cat$ un diagrama de forma $\mathcal{I}$.
Un \newterm{cono} en el diagrama $D$ es un objeto $V \in \cat$ (que llamamos \newterm{vértice}) y una familia de morfismos $f_A \colon C \to D A$ para todo $A \in \mathcal{I}$, tal que para todo morfismo $g \colon A \to B$ de $\mathcal{I}$, el siguiente diagrama conmuta:
\[ \begin{tikzcd}
 & D A \arrow[dd,"D g"]\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"]\\
 & D B
\end{tikzcd} \]
\end{definition}

Una buena técnica para estudiar una nueva construcción es preguntarse: ¿Podemos formar una categoría con ella?

Lo que nos queda por hacer para crear una categoría de conos de un diagrama fijo $D$ es definir un morfismo entre conos.
Resulta intuitivo definirlo a partir de un morfismo entre los vértices.
Si $C$ y $C'$ son dos conos con vértices $V$ y $V'$ respectivamente, definimos el morfismo $C \colon C'$ como un morfismo $u \colon V \to V'$ tal que el siguiente diagrama conmuta para todo $A \in \mathcal{I}$:
\[ \begin{tikzcd}
V \arrow[dr,"f_A"] \arrow[dd,"u"] &\\
 & D A\\
V' \arrow[ur,"f'_A"]
\end{tikzcd} \]

\begin{proposition}
Dado una categoría $\cat$ y un diagram $D \colon \mathcal{I} \to \cat$, los conos de $D$ forma una categoría llamada $\text{Cono}(D)$ con los morfismos descritos anteriormente.
\end{proposition}
La demostración es directa gracias a que $\cat$ es una categoría.

En esta categoría de conos, resulta de especial interés el objeto terminal.

\begin{definition}
Dado una categoría $\cat$ y un diagrama $D \colon \mathcal{I} \to \cat$, el \newterm{límite del diagrama} $D$ es el objeto terminal de $\text{Cono}(D)$.
\end{definition}

Usaremos la notación $\underset{\longleftarrow}\lim D$ para referirnos al límite de un diagrama si existe.

Podemos considerar el dual de estos conceptos.

\begin{definition}
Un \newterm{cocono} de $\cat$ es un cono de $\cat^{op}$.
En otras palabras, un cocono en un diagrama $D \colon \mathcal{I} \to \cat$ es un objeto $V \in \cat$ y una familia de morfismos $f_A \colon D A \to V$ para todo $A \in \mathcal{I}$, tal que para todo morfismo $g \colon B \to A$ de $\mathcal{I}$, el siguiente diagrama conmuta:
\[ \begin{tikzcd}
 & D A \arrow[dl,"f_A"]\\
V\\
 & D B \arrow[ul,"f_B"] \arrow[uu,"D g"]
\end{tikzcd} \]
\end{definition}

\begin{definition}
Un \newterm{colímite} es el objeto terminal de la categoría de coconos de un diagrama. Equivalentemente es el objeto inicial de la categoría de conos.
\end{definition}

\begin{definition}
Una categoría $\cat$ es \index{categoría!completa}\index{categoría!cocompleta}\emph{(co)completa} si existen todos los (co)límites de diagramas $D \colon \mathcal{I} \to \cat$ con $\mathcal{I}$ categoría pequeña.

Una categoría es \index{categoría!bicompleta}\emph{bicompleta} si es completa y cocompleta.
\end{definition}

\section{Productos y coproductos}

Resulta importante familiarizarse con la idea de límite antes de continuar, porque nos resultará muy útil para definir nuevos conceptos.

\begin{definition}
Sea $\mathcal{I}$ la categoría de dos objetos $I_1$ y $I_2$ y sin morfismos aparte de los morfismos identidad. El \newterm{producto} de dos objetos $A$ y $B$ en $\cat$ es el límite del diagrama $D \colon \mathcal{I} \to \cat$ con $D(I_1) = A$ y $D(I_2) = B$.

Escribiremos $A \times B$ para denotar el producto de $A$ y $B$.
\end{definition}

Desenvolvamos las definiciones para entender que significa realmente el producto de dos objetos $A$ y $B$.
Primero obsérvese que el diagrama $D$ actúa para \textquote{seleccionar} los objetos $A$ y $B$ y sus morfismos identidad.
Puede que haya algún morfismo entre $A$ y $B$, pero no son relevantes para el diagrama y, en consecuencia, ni para el límite.

Un cono sobre $D$ es de la forma:
\begin{equation}\label{producto-cono} \begin{tikzcd}
 & A\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"]\\
 & B
\end{tikzcd} \end{equation}

El producto $A \times B$, límite de $D$, puede ser visto como el cono terminal en la categorías de conos sobre $D$.
Es decir, para todo cono como en \ref{producto-cono}, debe existir un único morfismo de dicho cono al $A \times B$.
Desenvolvamos las definiciones aún más.
Digamos que el producto está formado por los objetos $A \times B$ (abusando un poco de notación aquí), $p_A \colon A \times B \to A$ y $p_B \colon A \times B \to B$.
Para todo $V$, $f_A \colon V \to A$ y $f_B \colon V \to B$, debe existir un $h \colon V \to A \times B$ tal que el siguiente diagrama conmute:

\[\begin{tikzcd}
 & A\\
V \arrow[ur,"f_A"] \arrow[dr,"f_B"] \arrow[r,dashed,"h"] & A \times B \arrow[u,"p_A"] \arrow[d,"p_B"]\\
 & B
\end{tikzcd}\]

o algebraicamente:
\[ f_A = p_A \circ h \]
\[ f_B = p_B \circ h \]
Es decir, podemos dar un par de morfismos $V \to A$ y $V \to B$ es equivalente a dar un morfismo $V \to A \times B$.
Luego, podemos volver a los objetos $A$ y $B$ usando unos morfismos fijos $p_A$ y $p_B$ (que llamamos \index{morfismo!proyección}\emph{proyecciones}).

\begin{definition}
Sea $\mathcal{I}$ la categoría de dos objetos $I_1$ y $I_2$ y sin morfismos aparte de los morfismos identidad. El \newterm{coproducto} de dos objetos $A$ y $B$ en $\cat$ es el colímite del diagrama $D \colon \mathcal{I} \to \cat$ con $D(I_1) = A$ y $D(I_2) = B$.

Escribiremos $A \oplus B$ para denotar el coproducto de $A$ y $B$.
\end{definition}

Desarrollando como antes la definiciones tenemos que para todo $V$, $f_A \colon A \to V$, $f_B \colon B \to V$, se tiene que existe $h \colon A \oplus B \to V$ tal que:

\[\begin{tikzcd}
 & A \arrow[dl,"f_A"] \arrow[d,"i_A"]\\
V & A \oplus B \arrow[l,dashed,"h"]\\
 & B \arrow[ul,"f_B"] \arrow[u,"i_B"]
\end{tikzcd}\]
donde $i_A$ e $i_B$ son llamadas \newterm{inyecciones naturales}.

\begin{example}
No es de extrañar que en $\Set$, el producto de dos objetos es el producto cartesiano de dos conjuntos.
Por otro lado, el coproducto de dos conjuntos se corresponde con la unión disjunta.
\end{example}

\begin{example}\label{ejemplo-producto-pos}
Consideramos la categoría $Pos$ de conjuntos parcialmente ordenados (posets) donde los morfismos son funciones monótonas.
El producto de dos posets $P$ y $Q$ es un poset $P \times Q$ de pares $(p,q)$ con $p \in P$ y $q \in Q$ ordenado parcialmente por:
\[ (p,q) \leq (p',q') \sii p \leq p' \text{ y }q \leq q' \]
Las proyecciones $p_1 \colon P \times Q \to P$ y $p_2 \colon P \times Q \to Q$ son evidentemente monótonas, luego son morfismos de $Pos$.
\end{example}

\begin{example}
En $\Hask$, el producto de dos tipos \code{a} y \code{b} es el par \code{(a,b)} y las proyecciones son las funciones \code{fst :: (a,b) -> a} y \code{snd :: (a,b) -> b}.
También tenemos que \code{(a,b)} es isomorfo a:
\begin{minted}{haskell}
newtype Pair a b = Pair a b
\end{minted}
A su vez, el coproducto de dos tipos \code{a} y \code{b} es el tipo \code{Either a b}, cuya definición es:
\begin{minted}{haskell}
data Either a b = Left a | Right b
\end{minted}
Es más, tenemos que todos los tipos de datos compuestos son isomorfos a productos y coproductos.
\end{example}

Podemos definir producto $n$-ario de objetos como el límite de un diagrama con una categoría índice discreta (es decir, sin morfismos a parte de los morfismos identidad) de $n$ objetos.
\begin{remark}\mbox{}
\begin{itemize}
  \item Si existen productos binarios, entonces existe cualquier produco $n$-ario con $n \geq 2$.
  \item En el caso particular de $n=1$, el $1$-producto de cualquier objeto es precisamente el mismo objeto.
  \item En el caso particular de $n=0$, el $0$-producto es precisamente el objeto terminal.
\end{itemize}
\end{remark}

Por esta razón, cuando una categoría tiene productos binarios y objeto terminal, se dice que tiene \emph{todos los productos finitos}.

Hemos visto el producto y el coproducto como casos particulares de límites.
Otros límites importantes son:
\begin{definition}
Dado un diagrama \newterm{span}
\[ \begin{tikzcd}
A & B \arrow[l] \arrow[r] & C
\end{tikzcd} \]
sobre una categoría, su colímite se denomina \newterm{pushout}.
\end{definition}

Un uso típico de pushouts está presente en topología:
\begin{example} % https://ncatlab.org/nlab/show/limits+and+colimits+by+example#pullback
Dado un span
\[ \begin{tikzcd}
X & A \arrow[l,"f" above] \arrow[r,"i"] & Y
\end{tikzcd} \]
en $\Top$, donde $i \colon A \to Y$ es una inclusión, entonces el pushout se llama \newterm{espacio de adjunción} y se escribe $X \cup_f Y$.
El espacio de adjunción se corresponde con el espacio cociente de la unión disjunta de $X$ e $Y$ bajo la relación de equivalencia generada por $x \sim f(x)$. 
\end{example}

\begin{definition}
Dado un diagrama \newterm{cospan} (dual de span)
\[ \begin{tikzcd}
A \arrow[r] & B & C \arrow[l]
\end{tikzcd} \]
sobre una categoría, su límite se denomina \newterm{pullback}.
\end{definition}
\begin{definition}
Dado un diagrama de \newterm{pareja paralela}
\[ \begin{tikzcd}
A \arrow[r,bend left] \arrow[r,bend right] & B
\end{tikzcd} \]
sobre una categoría, su límite se denomina \newterm{ecualizador} y su colímite, \newterm{coequalizador}.
\end{definition}

En resumen:

\begin{center}
\begin{tabular}{ c | c | c }
  Forma & Límite & Colímite\\
  \hline
  $\emptyset$ & Objeto terminal & Objeto inicial \\
  Discreta finita & Producto & Coproducto \\
  Span & - & Pushout \\
  Cospan & Pullback & - \\
  Pareja paralela & Ecualizador & Coecualizador
\end{tabular}
\end{center}

\section{Transformaciones naturales}
\begin{definition}
Una transformación natural $\mu$ entre dos functores $F, G \colon \cat \to \mathcal{D}$ es una colección de funciones
\[ \mu_A \colon F A \to G A \]
donde $A \in \cat$ tal que para todo $f \colon A \to B$ el diagrama:
\[
\begin{tikzcd}
F A \arrow[r,"\mu_A"] \arrow[d,"F f"] & G A \arrow[d,"G f"]\\
F B \arrow[r,"\mu_B"] & G B
\end{tikzcd}
\]
conmuta.
\end{definition}

Usaremos la notación $\mu \colon F \Rightarrow G$ para una transformación natural $\mu$.
Llamamos $\mu_A$ \newterm{componente} de $\mu$ en $A$.

\begin{definition}
Dado dos transformaciones naturales $\mu \colon F \Rightarrow G$ y $\eta \colon G \Rightarrow H$ donde $F,G,H \colon \cat \to \mathcal{D}$ son functores, su composición $\mu \circ \eta \colon F \Rightarrow H$ viene dada por
\[ (\mu \circ \eta)_A = \mu_A \circ \eta_A \]
para todo objeto $A \in \cat$.
\end{definition}

\begin{lemma}
Dados dos categorías $\cat$ y $\mathcal{D}$, existe una categoría donde los objetos son functores $\cat \to \mathcal{D}$ y los morfismos son transformaciones naturales.

Denotamos dicha categoría como $\mathcal{D}^\cat$ ó $[\cat,\mathcal{D}]$.
\end{lemma}
\begin{proof}
Vemos primero que podemos definir una transformación natural identidad $\iota \colon F \Rightarrow F$ dado por $\iota_A = \id_{F A}$ para todo $A \in \cat$.
Por otro lado, que la composición de transformaciones naturales es asociativa es trivial.
\end{proof}

\section{Functores adjuntos}
Los functores adjuntos son, en esencia, una forma débil de inversa de functores.
Antes de entrar formalmente en ellos, veamos un par de ejemplos que ilustren la noción que formalizaremos.

\begin{example}
Consideremos el caso de dos conjuntos pre-ordenados $\cat$ y $\mathcal{D}$.
Podemos verlos como categorías, donde los objetos son los elementos del conjunto y hay un morfismo $A \to B$ si $A \leq B$.
Una funcion $F \colon \cat \to \mathcal{D}$ que mantiene el orden puede ser visto sencillamente como un functor sobre estas categorías.

Un functor $G \colon \mathcal{D} \to \cat$ es un \newterm{adjunción derecha} a $F$ si, para todo $A \in \cat$ y $B \in \mathcal{B}$:
\[ F A \leq B \sii A \leq G B \]
\end{example}

\begin{example}
Sea $U \colon \Grp \to \Set$ el functor natural de grupos a conjuntos y sea $F \colon \Set \to \Grp$ el functor que asocia a cada conjunto su correspondiente grupo libre.
\end{example}

\begin{definition}
Una \newterm{adjunción} entre categorías $\cat$ y $\mathcal{D}$ son functores
\[ F \colon \cat \to \mathcal{D} \qquad U \colon \mathcal{D} \to \cat \]
y una transformación natural:
\[ \eta \colon \Id_\cat \Rightarrow U \circ F \]
tal que para todo $A \in \cat$, $B \in \mathcal{D}$ y $f \colon A \to U B$, existe un único $f^* \colon F A \to B$ tal que el siguiente diagrama conmuta:
\[
\begin{tikzcd}
U (F A) \arrow[dr,"U f^*"]\\
& U B\\
A \arrow[ur,"f"] \arrow[uu,"\eta_A"]
\end{tikzcd}
\]
\end{definition}

Llamamos $F$ \newterm{adjunta izquierda}, $U$ \newterm{adjunta derecha} y $\eta$ es la \newterm{unidad} de la adjunción.

\chapter{Categorías cartesianamente cerradas}
\section{Exponencial}
Si $\cat$ tiene productos binarios, entonces el \newterm{exponencial} de los objetos $B$ y $C$ de $\cat$ es el objeto
\[ C^B \]
y un morfismo:
\[ \varepsilon \colon C^B \times B \to C \]
tal que para todo objeto $A$ y morfismo
\[ f \colon A \times B \to C \]
hay un único morfismo
\[ \lambda_f \colon A \to C^B \]
tal que el siguiente diagrama conmuta:

\[
\begin{tikzcd}
C^B \times B \arrow[rr,"\varepsilon"] & & C \\\\
A \times B \arrow[uu,"\lambda_f\times\id_A"]  \arrow[uurr,"f"]
\end{tikzcd}
\]

El morfismo $\varepsilon$ se denomina \newterm{evaluación}.
El morfismo $\lambda_f$ se denomina \newterm{transposición} o \newterm{currificación} de $f$.

Obsérvese que
\begin{align*}
\lambda \colon C(A \times B, C) & \to C(A,C^B)\\
f & \mapsto \lambda_f
\end{align*}
es un isomorfismo por la existencia e unicidad de $\lambda_f$ por cada $f$.

En programación funcional, la currificación resulta de gran utilidad.
En Haskell, por ejemplo, se usa la función \code{curry} de tipo:
\begin{minted}{haskell}
curry :: ((a, b) -> c) -> a -> b -> c
\end{minted}
Su inversa es \code{uncurry}, de tipo:
\begin{minted}{haskell}
uncurry :: (a ->  b -> c) -> (a, b) -> c
\end{minted}

\section{Categorías cerradas cartesianas}
\begin{definition}
Decimos que una categoría es \index{categoría!cartesianamente cerrada}\newterm{cartesianamente cerrada} si cumple las siguientes condiciones:
\begin{enumerate}
\item Tiene un objeto terminal.
\item Tiene el producto de dos objetos cualesquiera.
\item Tiene el exponencial de dos objetos cualesquiera.
\end{enumerate}
\end{definition}

\begin{example}
Consideramos la categoría $Pos$ de conjuntos parcialmente ordenados donde los morfismos son funciones monótonas del que hablamos en \ref{ejemplo-producto-pos}.
Sean $P$ y $Q$ posets, veamos que $Q^P = \{ f \colon Q \to P \mid f \text{ monótona}\}$ con el orden:
\[ f \leq g \sii f(p) \leq g(p) \text{ para todo }p \in P \]
El morfismo evaluación es:
\[ \varepsilon (f,p) = f(p) \]
Veamos que efectivamente $\varepsilon$ es un morfismo.
Supongamos que $(f,p) \leq (f',p')$, entonces:
\begin{align*}
\varepsilon(f,p) & = f(p) & \\
& \leq f(p') & \text{ por ser }f\text{ monótona y }p\leq p'\\
& \leq f'(p') & \text{ por ser }f \leq f'\\
& = \varepsilon(f',p')
\end{align*}
Luego $\varepsilon$ es un morfismo $Pos$.
Sea $f \colon X \times P \to Q$ monótona y sea $x \leq x'$.
\begin{align*}
\lambda_f(x)(p) & = f(x,p) & \\
& \leq f(x',p) & \text{pues }(x,p) \leq (x',p)\\
& \leq f'(x',p) & \text{pues }f \leq f'\\
& = \lambda_f(x')(p)
\end{align*}
\end{example}

\begin{lemma}
En una categoría cartesianamente cerrada $\cat$, la exponenciación por un objeto fijo es un functor.
\end{lemma}
\begin{proof}
Queremos probar que la exponenciación:
\[ -^Z \colon \cat \to \cat \]
para un objeto fijo $Z$ es un endofunctor.
Como $\cat$ es cartesianamente cerrada, la exponenciación de $A^Z$ está bien definido para todo objeto $A$ de $\cat$.
Consideremos ahora un morfismo $f \colon A \to B$, tenemos que definir $f^Z \colon A^Z \to B^Z$.
Primero observamos que:
\[ \varepsilon \colon A^Z \times Z \to A \]
Luego:
\[ f \circ \varepsilon \colon A^Z \times Z \to B\]
Transponiendo:
\[ \lambda_{f \circ \varepsilon} \colon A^Z \to B^Z \]
Así que definimos $f^Z$ como $\lambda_{f \circ \varepsilon}$.

Tenemos el siguiente diagrama conmutativo consecuencia de la transposición:
\[
\begin{tikzcd}
B^Z \times Z \arrow[rr,"\varepsilon"] & & B \\\\
A^Z \times Z \arrow[uu,"\lambda_{f\circ \varepsilon}\times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]

Luego considerando $(\id_A)^Z$:
\[
\begin{tikzcd}
A^Z \times Z \arrow[rr,"\varepsilon"] & & A \\\\
A^Z \times Z \arrow[uu,"(\id_A)^Z\times\id_Z"]  \arrow[uurr,"\varepsilon"]
\end{tikzcd}
\]
Como $\id_{A^Z}$ cumple también el anterior diagrama y tenemos que el morfismo que cumple el diagrama es único, $(\id_A)^Z = \id_{A^Z}$.

Por otro lado, si tenemos morfismos: $f \colon A \to B$ y $g \colon B \to C$, tenemos que $(g \circ f)^Z$ es el único que conmuta el diagrama:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C \\\\
A^Z \times Z \arrow[uu,"(g \circ f)^Z \times\id_Z"]  \arrow[uurr,"g \circ f \circ \varepsilon"]
\end{tikzcd}
\]
Sin embargo, observamos que también conmuta:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
B^Z \times Z \arrow[rr,"\varepsilon"] \arrow[uu,"g^Z \times \id_Z"] \arrow[uurr,"g \circ \varepsilon"] & & B \\\\
A^Z \times Z \arrow[uu,"f^Z \times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]
Podemos reemplazar la flecha diagonal $g \circ \varepsilon$ obteniendo:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
B^Z \times Z \arrow[rr,"\varepsilon"] \arrow[uu,"g^Z \times \id_Z"] & & B \arrow[uu,"g"] \\\\
A^Z \times Z \arrow[uu,"f^Z \times\id_Z"]  \arrow[uurr,"f \circ \varepsilon"]
\end{tikzcd}
\]
Finalmente, este diagrama implica que:
\[
\begin{tikzcd}
C^Z \times Z \arrow[rr,"\varepsilon"] & & C\\\\
A^Z \times Z \arrow[uu,"(g^Z \circ f^Z) \times\id_Z"]  \arrow[uurr,"g \circ f \circ \varepsilon"]
\end{tikzcd}
\]
conmuta, luego prueba por unicidad que $(g \circ f)^Z = g^Z \circ f^Z$.

Esto demuestra que $-^Z$ es un endofunctor.
\end{proof}

Más atrás, consideramos la categoría de functores entre dos categorías $\cat$ y $\mathcal{D}$.
Consideramos ahora la \index{categoría!{de categorías pequeñas}}\emph{categoría de categorías pequeñas}, denominada \index{Cat@$\Cat$|see {categoría de categorías pequeñas}}$\Cat$, con functores como morfismos.

Vamos a ver que $\Cat$ es cartesianamente cerrada.
\begin{proposition}
\end{proposition}

\chapter{F-álgebras}
\begin{definition}
Sea $\cat$ una categoría y $F \colon \cat \to \cat$ un endofunctor.
Una $F$-álgebra es un par $(A,\alpha)$, donde $A \in \cat$ y $\alpha \colon F a \to a$ es un morfismo de $\cat$.
\end{definition}

% A taste of category theory for computer scientist
En algunos libros, también se le llama \newterm{punto prefijo}.
Aunque no usaremos el nombre de punto prefijo, sí diremos que si $\alpha$ es isomorfismo, al par $(A,\alpha)$ par se le llama también \newterm{punto fijo}, señalando su similitud con la idea de punto fijo habitual de análisis.

Puede ser interesante darle una estructura de categoría a la colleción de $F$-álgebras.
Para ello, necesitamos definir morfismos de un $(A,\alpha)$ a $(B,\beta)$.
Suponiendo que tenemos un morfismo $f \colon A \to B$, observamos que $F f \colon F A \to F B$, que puede ser compuesta con $\beta$:
\[ \beta \circ F f \colon F A \to B \]
Por otro lado:
\[ f \circ \alpha \colon F A \to B \]
La igualdad de estos dos morfismos nos dará la fundación de la categoría de $F$-álgebras.
Es más, como estos morfismos preservan bien la estructura de $F$-álgebran, les daremos el nombre (honorífico) de $F$-homomorfismo:

\begin{proposition}\label{prop:fmorfismo}
Sea $\cat$ una categoría y $F$ un endomorfismo en $\cat$.
Sea $Alg_F$ la colección de $F$-álgebras con homomorfismos $f \colon (A,\alpha) \to (B,\beta)$ tal que:
\begin{itemize}
\item $f \colon A \to B$ es un morfismo de $\cat$.
\item El siguiente diagrama conmuta
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F f"] & A \arrow[d,"f"]\\
F B \arrow[r,"\beta"] & B
\end{tikzcd}
\]
\end{itemize}
Entonces $Alg_F$ forma una categoría.
\end{proposition}
\begin{proof}
Basta ver que la composición está bien definida, pues las demás condiciones se cumplen trivialmente.
Sean $f \colon (A,\alpha) \to (B,\beta)$ y $g \colon (B,\beta) \to (C,\gamma)$ homomorfismos de $F$-álgebras.
Entonces cada cuadrado del siguiente diagrama conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F f"] & A \arrow[d,"f"]\\
F B \arrow[r,"\beta"] \arrow[d,"F g"] & B \arrow[d,"g"]\\
F C \arrow[r,"\gamma"] & C
\end{tikzcd}
\]
Tenemos que:
\[ g \circ f \circ \alpha = g \circ \beta \circ F f = \gamma \circ F g \circ F f \]
Como $F g \circ F f = F (g \circ f)$, tenemos que el siguiente diagrama conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F (g \circ f)"] & A \arrow[d,"g \circ f"]\\
F C \arrow[r,"\gamma"] & C
\end{tikzcd}
\]
Luego $g \circ f$ es un homomorfismo de $F$-álgebras.
\end{proof}

Una vez hemos determinado una nueva categoría, podemos empezar a buscar qué aspecto tienen nuestra construcciones universales en esta nueva categoría.
Resultará de particular interés el objeto inicial de una $Alg_F$ por el siguiente lema debido a Lambek~\cite{lambek}:

\begin{lemma}
Sea $F \colon \cat \to \cat$ un endofunctor.
Si $(A,\alpha)$ es una $F$-álgebra inicial de $Alg_F$, entonces $(A,\alpha)$ es un punto fijo de $F$.
\end{lemma}
\begin{proof}
Sea $(A,\alpha)$ un objeto inicial en $Alg_F$.
Para decir que $(A,\alpha)$ es un punto fijo, debemos ver que $\alpha$ es un isomorfismo.
Para ello consideramos el $F$-álgebra $(F A, F \alpha)$.
Como $(A,\alpha)$ es inicial, existe un único homomorfismo $u \colon (A, \alpha) \to (F A, F \alpha)$.

Por un lado, $\alpha \circ u \colon (A, \alpha) \to (A, \alpha)$, pero el único homomorfismo de un objeto inicial a sí mismo es el morfismo identidad, luego $\alpha \circ u = \id_{(A, \alpha)}$.
Por definición de homomorfismo, el siguiente diagram conmuta:
\[
\begin{tikzcd}
F A \arrow[r,"\alpha"] \arrow[d,"F u"] & A \arrow[d,"u"]\\
F (F A) \arrow[r,"F \alpha"] & F A
\end{tikzcd}
\]
Entonces:
\[ u \circ \alpha = F \alpha \circ F u = F (\alpha \circ u) = F (\id_{(A, \alpha)}) = \id_{(F A, F \alpha)} \]
Luego $\alpha$ tiene inversa y debe ser isomorfismo.
\end{proof}

Dado un $F$-álgebra inicial $(A,\alpha)$, para todo otro $F$-áĺgebra $(B,\beta)$, al homomorfismo único de $(A,\alpha)$ a $(B,\beta)$ le daremos el imponente nombre de \newterm{catamorfismo}.
Por ejemplo, el homomorfismo $u$ de la demostración era un catamorfismo a $(F A, F \alpha)$.

\section{Catamorfismos en Haskell}

Debemos empezar implementando álgebras en Haskell:
\begin{minted}{haskell}
type Algebra f a = f a -> a
\end{minted}
Hay que tener en cuenta que no estamos imponiendo que \code{f} sea un functor, ya que Haskell no permite imponer restricciones a constructores de datos sin recurrir a GADTs\footnote{\url{https://wiki.haskell.org/Data_declaration_with_constraint}}.

Lo siguiente que necesitamos es implementar el punto fijo de \code{f}:
\begin{minted}{haskell}
newtype Fix f = U (f (Fix f))
\end{minted}
Como \code{Fix} tiene un único constructor, hay un isomorfismo entre \code{Fix f} y \code{f (Fix f)}.
Este isomorfismo es \code{U}, y su inversa es:
\begin{minted}{haskell}
unFix :: Fix f -> f (Fix f)
unFix (U f) = f
\end{minted}

Ahora que sabemos que (\code{Fix f}, \code{U}) es el álgebra inicial, sabemos que existe un catamorfismo de este álgebra a todas las demás álgebras.
Consideramos cualquier otra álgebra (\code{b}, \code{g}), con \code{g :: Algebra f b}. sea \code{m :: Fix f -> b} el correspondiente catamorfismo, entonces por \ref{prop:fmorfismo}:

\[
\begin{tikzcd}
{f (Fix f)} \arrow[r,"fmap\ m"] \arrow[d,"U"] & f b \arrow[d,"g"]\\
{Fix f} \arrow[r,"m"] & b
\end{tikzcd}
\]

Podemos invertir \code{U} con \code{unFix}, luego la conmutatividad del diagrama es equivalente a que:
\begin{minted}{haskell}
m = g . fmap m . unFix
\end{minted}
Usamos esto para definir recursivamente el catamorfismo:
\begin{minted}{haskell}
cata :: (Functor f) => (Algebra f b) -> (Fix f -> b)
cata g = g . fmap (cata g) . unFix
\end{minted}

Veamos un ejemplo con el functor \code{Maybe}
\begin{example}
Especialicemos el código anterior para \code{Maybe}:
\begin{minted}{haskell}
type AlgebraM a = Algebra Maybe a
type FixM = Fix Maybe
\end{minted}
Por ahora, no dice mucho. Pero al añadir las siguientes de líneas obtenemos una perspectiva interesante:
\begin{minted}{haskell}
type Nat = FixM

cero :: Nat
cero = U Nothing
suc :: Nat -> Nat
suc = U . Just
\end{minted}
Es decir, los naturales pueden verse como el punto fijo del functor \code{Maybe}.
\end{example}
%Para ilustrar la utilidad de los catamorfismos, vamos a construir una álgebra inicial en \code{Hask} sobre el functor \code{[]} (listas).
%En este caso, un \code{[]}-álgebra será un par \code{(a,alpha)} donde \code{alpha :: [a] -> a}.
%Digamos que \code{a = Int}
%Para que esta $F$-álgebra sea inicial, necesitamos un \code{cat :: Int -> [Int]} que sea la inversa de \code{alpha}.

\chapter{Lema de Yoneda}

El lema de Yoneda es uno de los resultados más importante, pues el relacionado embebimiento de Yoneda es una herramienta poderosa para demostrar otros resultados.

En este capítulo, siempre estaremos trabajando con categorías localmente pequeñas.

\section{Hom-Functores}
Consideremos la categoría de functores de una categoría $\cat$ a $\Set$, que podemos denotar como $\Set^\cat$.
En esta categoría, los objetos son functores y los morfismos son transformaciones naturales entre functores.

Como estamos bajo la hipótesis que $\cat$ es localmente pequeña, entonces $C(A,B)$ es un conjunto para todo $A \in \cat$ y $B \in \cat$.
Entonces, $C(A,B) \in \Set$.
De este hecho, podemos crear el functor contravariante:
\[ C(A,-) \colon \cat \to \Set \]
que a cada objeto $X \in \cat$ le asocia el conjunto $C(A,X)$.
A cada morfismo $f \colon X \to Y$ en $\cat$, $C(A,f)$ será un morfismo entre los conjuntos $C(A,X)$ y $C(A,Y)$.
La forma natural de asociar estos conjuntos es por la composición $g \mapsto f \circ g$.
A dicho functor le damos el nombre de \newterm{hom-functor}.

Veamos que el hom-functor es realmente un functor.

\[ C(A,\id_B)(g) = g \circ \id = g \Rightarrow C(A,\id_B) = \id_{C(A,B)} \]
\begin{align*}
C(A,g \circ f)(h) & = (g \circ f) \circ h = g \circ (f \circ h)\\
& = g \circ C(A,f)(h) = C(A,g)(C(A,f)(h))\\
& = C(A,g) \circ C(A,f)\ (h)
\end{align*}

Luego $C(A,-)$ respeta el morfismo unidad y la composición de morfismos, luego es efectivamente un functor de $\cat \to \Set$.
Equivalentemente, tenemos que $C(A,-)$ es un objeto de $\Set^\cat$.

Digamos que tenemos un objeto isomorfo a $C(A,-)$ en $\Set^\cat$.
Esto quiere decir que entre el objeto, visto como un functor, y $C(A,-)$ hay una transformación natural invertible, que también llamamos \newterm{isomorfismo natural}.
De aquí procede la siguiente definición: 

\begin{definition}
Un functor $F \colon \cat \to \Set$ es \newterm{representable} si es isomorfo naturalmente a un hom-functor.
\end{definition}

Es decir, un functor representable puede identificarse con $C(A,-)$ para algún $A$.

\subsection{Functores representables en Haskell}
% Milewski
En la categoría $\Hask$, el hom-functor recibe a menudo el nombre de \code{Reader}
\begin{minted}{haskell}
type Reader a x = a -> x
\end{minted}
Es decir, $C(A,-)$ es equivalente a \code{Reader a}, que es equivalente a \code{(->) a}.
Para que un functor \code{F} sea representable necesitamos una transformación natural invertible a \code{Reader a}, es decir, necesitamos:
\begin{minted}{haskell}
functorAreader :: f x -> (a -> x)
readerAfunctor :: (a -> x) -> f x
\end{minted}
tal que cada una sea la inversa de la otra.

Vamos a tomar de la librería para Haskell \textit{adjunctions} de Edward Kmett la siguiente implementación de functores representables:
\begin{minted}{haskell}
class (Functor f) => Representable f where
  type Rep f :: *
  index :: f x -> Rep f -> x
  tabulate :: (Rep f -> x) -> f x
\end{minted}
Nuestra función \code{functorAreader} es aquí \code{index}, \code{readerAfunctor} se convierte en \code{tabulate}.
El tipo \code{a} pasa a depender del functor \code{f} a través de \code{Rep f}.
Además, se establece que se deben cumplir:
\begin{minted}{haskell}
tabulate . return = return
tabulate . index  = id
index . tabulate  = id
\end{minted}
Las primera condición establece que \code{tabulate} sea una transformación natural. 
Las otras dos condiciones son equivalentes a dicha transformaión natural sea invertible con \code{index}.

\section{Inmersión de Yoneda}
Primero definamos qué es un inmersión.

Recordemos de la definición de functor, que un functor consistía en un par $F_O$ y $F_M$ que actúan sobre los objetos y morfismos respectivamente.
Dado un functor $F \colon \cat \to \mathcal{D}$ y dos objetos $A, B \in \cat$, denotamos por $F_M|_{\cat(A,B)}$ o, sencillamente, $F_{A,B}$ a la \textquote{restricción} de $F_M$ a la colección de morfismos $\cat(A,B)$.
Como $F_M$ respeta el dominio y codominio, tenemos que $F_{A,B}$ es una aplicación:
\[ F_{A,B} \colon \cat(A,B) \to \mathcal{D}(F A, F B) \]
Con esto en mente, definimos las siguientes clases de functores:

\begin{definition}
Un functor $F \colon \cat \to \mathcal{D}$ es 
\begin{itemize}
  \item \index{functor!lleno}\emph{lleno} si para cada $A,B \in \cat$, $F_{A,B}$ es sobreyectiva.
  \item \index{functor!fiel}\emph{fiel}, si para cada $A,B \in \cat$, $F_{A,B}$ es inyectiva.
  \item \index{functor!{inyectivo en objetos}}\emph{inyectivo en objetos} si $F_O$ es inyectivo.
\end{itemize}
\end{definition}

Obsérvese que no es lo mismo que $F$ sea lleno o fiel a que $F_M$ sea inyectiva y sobreyectiva.
Podríamos decir que la propiedad de ser lleno y fiel es una propiedad \textquote{local}.

\begin{definition}
Un functor es una \newterm{inmersión} si es fiel e inyectivo en objetos.
Si además es lleno, decimos que es una \newterm{inmersión llena}. 
\end{definition}

\begin{definition}
Dada una categoría $\cat$, una \newterm{subcategoría} es un par $(\mathcal{D}, F)$ donda $\mathcal{D}$ es una categoría y $F \colon \mathcal{D} \to \cat$ es una inmersión.

Si además, $F$ es llena, decimos que $(\mathcal{D}, F)$ es una \index{subcategoría!llena}\emph{subcategoría llena}.
\end{definition}

\begin{lemma}[Lema de Yoneda]
Sea $\cat$ una categoría localmente pequeña, un functor $F \colon \cat \to \Set$ y un objeto $A \in \cat$.
Denotemos por $Nat(\cat(A,-), F)$ a la colección de transformaciones naturales de $\cat(A,-) \Rightarrow F$.
Hay una biyección:
\[ Nat(\cat(A,-), F) \cong F A \]
que es natural en $A$ y en $F$.
\end{lemma}
% Category theory in context + Awodey
Vamos a precisar:
\begin{itemize}
  \item Hemos visto previamente que $\cat(A,-) \colon \cat \to \Set$ es un functor, luego puede haber una colección de transformaciones naturales de $\cat(A,-)$ al functor $F \colon \cat \to \Set$.
  \item  En la categoría de functores $\Set^{\cat}$, donde $\cat(A,-)$ y $F$ son objetos, $Nat(\cat(A,-),F)$ es precisamente la colección de morfismos $\Set^{\cat}(\cat(A,-),F)$.
  \item La naturalidad en $F$ quiere decir que para toda transformación natural $\theta \colon F \Rightarrow G$, se tiene que el siguiente diagrama es conmutativo:
\[
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\cong"] \arrow[dd,"{Nat(\cat(A,-),\theta)}" left] & & F A \arrow[dd,"\theta_A"]\\
  &\\
  {Nat(\cat(A,-),G)} \arrow[rr,"\cong"] & & G A
\end{tikzcd}
\]
  \item La naturalidad en $A$ quiere decir que para todo $f \colon A \to B$, se tiene que el siguiente diagrama conmuta:
  \[
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\cong"] \arrow[dd,"{Nat(\cat(f,-),F)}" left] & & F A \arrow[dd,"F f"]\\
  &\\
  {Nat(\cat(B,-),F)} \arrow[rr,"\cong"] & & F B
\end{tikzcd}
\]
  donde para una transformación natural $\mu \colon \cat(A,-) \Rightarrow F$ y morfismo $h \colon B \to C$:
  \[ (Nat(\cat(f,-),F)\mu)_C(h) = \mu_C \circ \cat(f,C)(h) = \mu_C (h \circ f) \]
\end{itemize}
\begin{proof}
Primero miramos que para una transformación natural $\mu \in Nat(\cat(A,-),F)$, es decir, $\mu \colon \cat(A,-) \Rightarrow F$, su componente en $A \in \cat$ es una función entre conjuntos
\[ \mu_A \colon \cat(A,A) \to F A \]
Sabemos además que $\cat(A,A)$ es un conjunto no vacío, pues al menos contiene $\id_A$

Consideramos la función $\phi \colon Nat(\cat(A,-),F) \to F A$ definida por:
\begin{align*}
  \phi \colon Nat(\cat(A,-),F) & \to F A\\
  \alpha & \mapsto \alpha_A(\id_A)
\end{align*}

Dado cualquier $x \in F A \in \Set$, definimos la transformación natural 
\[ \psi(x) \colon \cat(A,-) \Rightarrow F \]
estableciendo su componente para $B \in \cat$ cualquiera:
\begin{align*}
  \psi(x)_B \colon \cat(A,B) & \to F B\\
  \psi(x)_B (f) & \mapsto (F f)(x)
\end{align*}

Veamos que $\psi(x)$ cumple la naturalidad. Para un $f \colon B \to C$:
\begin{equation}\label{psi-diagrama}
\begin{tikzcd}
  {\cat(A,B)} \arrow[rr,"\psi(x)_B"] \arrow[dd,"{\cat(A,f)}"] & & F B \arrow[dd,"F f"]\\
  &\\
  {\cat(A,C)} \arrow[rr,"\psi(x)_C"] & & F C
\end{tikzcd}
\end{equation}
Tenemos que para todo $h \colon A \to B$:
\begin{align*}
(\psi(x)_C \circ \cat(A,f)) (h) & = \psi(x)_C (f \circ h)\\
& = (F (f \circ h))(x)\\
& = (F f) \circ (F h)(x)\\
& = (F f)(\psi(x)_B(h))\\
& = (F f) \circ (\psi(x)_B)(h)
\end{align*}
Luego el diagrama \ref{psi-diagrama} conmuta.

Veamos que $\phi$ y $\psi$ son inversas. Para $x \in F A$:
\begin{align*}
 \phi(\psi(x)) & = \psi(x)_A(\id_A)\\
 & = (F (\id_A))(x)\\
 & = \id_{F A}(x) & \text{por definición de functor}\\
 & = x
\end{align*}
Para $\mu \colon \cat(A,-) \Rightarrow F$, $B \in \cat$ y $h \colon A \to B$:
\begin{align*}
 \psi(\phi(\mu))_B(h) & = \psi(\mu_A(\id_A))_B(h)\\
 & = (F h)(\mu_A(\id_A))\\
 & = (\mu_B)(C(A,h)(\id_A)) & \text{por naturalidad de }\mu\\
 & = \mu_B(h\circ \id_A)\\
 & = \mu_B(h)
\end{align*}
Luego $\phi$ y $\psi$ son inversas y $Nat(\cat(A,-),F) \cong F A$.
Veamos la naturalidad en $F$ y en $A$:
\begin{equation}\label{diagrama-F}
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\phi_F"] \arrow[dd,"{Nat(\cat(A,-),\theta)}" left] & & F A \arrow[dd,"\theta_A"]\\
  &\\
  {Nat(\cat(A,-),G)} \arrow[rr,"\phi_G"] & & G A
\end{tikzcd}
\end{equation}
Sea $B \in \cat$ y $\mu \colon \cat(A,-) \Rightarrow F$:
\begin{align*}
 \theta_A(\phi_F(\mu)) & = \theta_A(\mu_A(\id_A))\\
 & = (\theta \circ \mu)_A(\id_A)\\
 & = \phi_G(\theta \circ \mu)
\end{align*}
que demuestra que el diagrama \ref{diagrama-F} conmuta.

Sea $f \colon A \to B$ y $\mu \colon \cat(A,-) \Rightarrow F$:
\begin{equation}\label{diagrama-A}
\begin{tikzcd}
  {Nat(\cat(A,-),F)} \arrow[rr,"\phi_A"] \arrow[dd,"{Nat(\cat(f,-),F)}" left] & & F A \arrow[dd,"F f"]\\
  &\\
  {Nat(\cat(B,-),F)} \arrow[rr,"\phi_B"] & & F B
\end{tikzcd}
\end{equation}
\begin{align*}
 (F f)(\phi_A(\mu)) & = (F f)(\mu_A(\id_A))\\
 & = (\mu_B)(C(A,f)(\id_A)) & \text{por naturalidad de }\mu\\
 & = (\mu_B)(f \circ \id_A)\\
 & = (\mu_B)(\id_B \circ f)\\
 & = (\mu_B)(C(f,B)(\id_B))\\
 & = (\mu \circ C(f,-))_B(\id_B)\\
 & = (\phi_B)(\mu \circ C(f,-))
\end{align*}
que demuestra que el diagrama \ref{diagrama-A} conmuta y acaba la demostración.
\end{proof}

\begin{remark}
Considerando la categoría opuesta, se tiene que para todo objeto $A \in \cat$ y functor contravariante $F \colon \cat^{op} \Rightarrow \Set$ hay una biyección
\[ Nat(\cat(-,A), F) \cong F A\]
natural en $A$ y $F$.
\end{remark}

Nuestra primera aplicación del lema de Yoneda es usando $F = \cat(B,-)$.
Se tiene que:
\[ Nat(\cat(A,-),\cat(B,-)) \cong \cat(B,A) \]
Análogamente:
\[ Nat(\cat(-,A),\cat(-,B)) \cong \cat(A,B) \]
Esto motiva la inmersión de Yoneda:
\begin{definition}
Las \index{inmersión de Yoneda}\emph{inmersiones de Yoneda} covariante y contravariante son los morfismos:
\begin{align*} 
  Y \colon \cat & \to \Set^{\cat^{op}}\\
  A & \mapsto \cat(-,A)\\
  f \colon A \to B & \mapsto \cat(-,f) \colon \cat(-,A) \to \cat(-,B)
\end{align*}
\begin{align*} 
  K \colon \cat^{op} & \to \Set^{\cat}\\
  A & \mapsto \cat(A,-)\\
  f \colon A \to B & \mapsto \cat(f,-) \colon \cat(B,-) \to \cat(A,-)
\end{align*}
es decir, las \index{currificación}currificaciones del bifunctor $\cat(-,-) \colon \cat^{op} \times \cat \to \Set$.
\end{definition}
Obsérvese que $K$ es un functor contravariante y que $K A$ es un functor covariante $\cat^{op} \to \Set$.
Análogamente, $Y$ es un functor covariante a los functores contravariantes $\cat^{op} \to \Set$.

Veremos ahora que el uso de \textquote{inmersión} está justificado:
\begin{proposition}
Las inmersiones de Yoneda son inmersiones llenas.
\end{proposition}
\begin{proof}
Lo probamos para $Y$, primero obsérvese que
\[ \cat(A,B) = (Y B)A \cong \Set^{\cat^{op}}(Y A, Y B)\]

\end{proof}
\backmatter

\bibliographystyle{acm}
\bibliography{bibliografia}

\printindex

\end{document}
\documentclass[11pt]{article}
%Gummi|065|=)
\usepackage[utf8x]{inputenc}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage[spanish]{babel}
\usepackage{mathpazo}
\usepackage{verbatim}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{babel}
\SetUnicodeOption{mathletters}
\SetUnicodeOption{autogenerated}
\setlength\parindent{0pt}

\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5},
    basicstyle=\footnotesize,
}

\usepackage{amsmath}
\begin{document}
\begin{enumerate}
\item \textit{Show the isomorphism between \texttt{Maybe a} and \texttt{Either () a}.}

\begin{lstlisting}
maybe2either :: Maybe a -> Either () a
maybe2either Nothing = Left ()
maybe2either (Just a) = Right a

either2maybe :: Either () a -> Maybe a
either2maybe (Left ()) = Nothing
either2maybe (Right a) = Just a
\end{lstlisting}

\item \textit{Implement \texttt{Shape} in C++ or Java as an interface and create two classes: \texttt{Circle} and \texttt{Rect}. Implement \texttt{area} as a virtual function.}

\begin{lstlisting}
struct Shape {
	virtual ~Shape() {}
	virtual float area() = 0;
};

struct Circle : Shape {
	float r;
	Circle(float r) : r(r) {}
	float area() override {
		return M_PI * r * r;
	}
};

struct Rect : Shape {
	float d;
	float h;
	Rect(float d, float h) : d(d), h(h) {}
	float area() override {
		return d * h;
	}
};
\end{lstlisting}

\item \textit{We can easily add a new function \texttt{circ} that calculates the circumference of a \texttt{Shape}. Add \texttt{circ} to your C++ or Java implementation. What parts of the original code did you have to touch?}

\begin{lstlisting}
struct Shape {
	/* */
	virtual float circ() = 0;
};

struct Circle : Shape {
	/* */
	float circ() override {
		return 2.0 * M_PI * r;
	}
};

struct Rect : Shape {
	/* */
	float circ() override {
		return 2.0 * (d + h);
	}
};
\end{lstlisting}

\item \textit{Add a new shape, \texttt{Square}, to \texttt{Shape} and make all the necessary updates. What code did you have to touch in Haskell vs. C++ or Java?}

\begin{lstlisting}
struct Square : Rect {
	Square(float l) : Rect(l,l) {}
};
\end{lstlisting}

Por otro lado, en Haskell tenemos que cambiar bastante más codigo para implementar \texttt{Square} como un nuevo término del tipo suma \texttt{Shape}.

\item \textit{Show that $a+a=2 \times a$ holds for types (up to isomorphism).}

La ecuación se corresponde en teoría de tipos de Haskell con: \texttt{Either a a $\cong$ (Bool, a)}. Tomamos:
\begin{lstlisting}
f :: Either a a -> (Bool, a)
f (Left v) = (False, v)
f (Right v) = (True, v)

g :: (Bool, a) -> Either a a
g (False, v) = Left v
g (True, v) = Right v
\end{lstlisting}
Tenemos que $f$ es la inversa de $g$, pues:
\begin{lstlisting}
f . g (False, v) = f (Left v) = (False, v)
f . g (True, v) = f (Right v) = (True, v)

g . f (Left v) = g (False, v) = Left v
g . f (Right v) = g (True, v) = Right v
\end{lstlisting}

Luego los tipos \texttt{Either a a} y \texttt{(Bool, a)} son isomorfos.
\end{enumerate}
\end{document}

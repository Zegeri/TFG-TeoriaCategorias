\documentclass[11pt]{article}
%Gummi|065|=)
\usepackage[utf8x]{inputenc}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage[spanish]{babel}
\usepackage{mathpazo}
\usepackage{verbatim}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{babel}
\SetUnicodeOption{mathletters}
\SetUnicodeOption{autogenerated}
\setlength\parindent{0pt}

\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5},
    basicstyle=\footnotesize,
}

\usepackage{amsmath}
\begin{document}
\begin{enumerate}
\item \textit{Show that the two function \texttt{phi} and \texttt{psi} that form the Yoneda isomorphism in Haskell are inverses of each other.}

\begin{verbatim}
phi :: (forall x. (a -> x) -> F x) -> F a
phi alpha = alpha id

psi :: F a -> (forall x. (a -> x) -> F x)
psi fa h = fmap h fa
\end{verbatim}

Veamos que son inversas:

\begin{verbatim}
  phi (psi fa)
= { definition of phi }
  psi fa id
= { definition of psi }
  fmap id fa
= { functor law }
  id fa
= { definition of id }
  fa
\end{verbatim}

\begin{verbatim}
  psi (phi alpha) h
= { definition of psi }
  fmap h (phi alpha)
= { definition of phi }
  fmap h (alpha id)
= { ? }
\end{verbatim}

\item \textit{A discrete category is one that has objects but no morphisms other than identity morphisms. How does the Yoneda lemma work for functors from such a category?}

Si una categoría $C$ es discreta, entonces para todo $a \in C$, el hom-functor $C(a,-)$ envía $a$ al conjunto unitario $\{id_a\}$ y los demás objetos al conjunto vacío. $C(a,-)$ envía un morfismo $f$ a 

\item \textit{A list of units \texttt{[()]} contains no other information but its length. So, as a data type, it can be considered an encoding of integer. An empty list encodes zero, a singleton \texttt{[()]} (a value, not a type) encodes one, and so on. Construct another representation of this data type using the Yoneda lemma for the list functor.}
\end{enumerate}
\end{document}
